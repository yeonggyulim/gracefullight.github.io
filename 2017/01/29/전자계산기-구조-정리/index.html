<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#682984"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/icons/icon-180x180.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/icons/icon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/icons/icon-16x16.png"><link rel="mask-icon" href="/images/icons/icon-pinned-tab.svg" color="#682984"><link rel="manifest" href="/manifest.json"><meta name="msapplication-config" content="/images/icons/browserconfig.xml"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="EFs9XZuMFGzvOpvRVHI_2bKZs1BmAMxPGmoFxuMu4-o"><meta name="msvalidate.01" content="65AD1E28C0D057CEB3C68FBC0293E55B"><meta name="yandex-verification" content="6672f93d837354fb"><meta name="baidu-site-verification" content="yZEdU1ABcR"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"gracefullight.dev",root:"/",scheme:"Gemini",version:"7.7.2",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1,padding:18},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="불 대수영국 수학자 불에 의해 개발AND : 입력 값이 모두 1일 때 1 출력OR : 입력 값이 하나라도 1일 때 1 출력NOT : 부정 기본 공식합의 곱을 곱의 합으로 변환분배법칙 예외 : A ＋(B×C) &#x3D; (A ＋ B)(B ＋ C)드모르강(A ＋ B)&#96; &#x3D; A&#96;×B&#96;(A×B)&#96; &#x3D; A&#96;＋ B&#96;멱등A ＋ A &#x3D; AA×A &#x3D; A보수A ＋ A&#96; &#x3D; 1A×"><meta property="og:type" content="article"><meta property="og:title" content="전자계산기 구조 정리"><meta property="og:url" content="https://gracefullight.dev/2017/01/29/%EC%A0%84%EC%9E%90%EA%B3%84%EC%82%B0%EA%B8%B0-%EA%B5%AC%EC%A1%B0-%EC%A0%95%EB%A6%AC/index.html"><meta property="og:site_name" content="Gracefullight"><meta property="og:description" content="불 대수영국 수학자 불에 의해 개발AND : 입력 값이 모두 1일 때 1 출력OR : 입력 값이 하나라도 1일 때 1 출력NOT : 부정 기본 공식합의 곱을 곱의 합으로 변환분배법칙 예외 : A ＋(B×C) &#x3D; (A ＋ B)(B ＋ C)드모르강(A ＋ B)&#96; &#x3D; A&#96;×B&#96;(A×B)&#96; &#x3D; A&#96;＋ B&#96;멱등A ＋ A &#x3D; AA×A &#x3D; A보수A ＋ A&#96; &#x3D; 1A×"><meta property="og:locale" content="ko_KR"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg/275px-K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg.png"><meta property="article:published_time" content="2017-01-29T15:35:16.000Z"><meta property="article:modified_time" content="2020-03-15T14:22:42.392Z"><meta property="article:author" content="Gracefullight"><meta property="article:tag" content="정보처리"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg/275px-K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg.png"><link rel="canonical" href="https://gracefullight.dev/2017/01/29/%EC%A0%84%EC%9E%90%EA%B3%84%EC%82%B0%EA%B8%B0-%EA%B5%AC%EC%A1%B0-%EC%A0%95%EB%A6%AC/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><link rel="preconnect" href="https://busuanzi.ibruce.info"><link rel="preconnect" href="https://pagead2.googlesyndication.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><meta name="naver-site-verification" content="a73bfdbae0aa662dfbb30d15a87c1aec78aa9342"><script async src="https://cdn.jsdelivr.net/npm/pwacompat@latest/pwacompat.min.js"></script><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "Person",
    "name": "Gracefullight",
    "gender": "male",
    "url": "https://gracefullight.dev",
    "logo": "https://gracefullight.dev/images/icons/icon-144x144.png",
    "image": "https://gracefullight.dev/images/profile_dog.png",
    "email": "mailto:eks012@gmail.com",
    "jobTitle": "FullStack Developer",
    "memberOf": "Cafe24 Corp",
    "nationality": "Korean",
    "sameAs": [
      "https://github.com/gracefullight",
      "https://www.facebook.com/eunkwang.daniel.shin",
      "https://blog.naver.com/eks020"
    ]
  }</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-3004788392777865",enable_page_level_ads:!0})</script><script async src="https://cdn.onesignal.com/sdks/OneSignalSDK.js"></script><script>var OneSignal=window.OneSignal||[];OneSignal.push(function(){OneSignal.init({appId:"6876bd0f-994b-4d58-9d53-d053e0b2f9f5",autoResubscribe:!0,notifyButton:{enable:!0}}),OneSignal.setDefaultNotificationUrl("https://gracefullight.dev"),OneSignal.registerForPushNotifications()})</script><title>전자계산기 구조 정리 | Gracefullight</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-89261637-4"></script><script>if(CONFIG.hostname===location.hostname){function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-89261637-4")}</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/feed.xml" title="Gracefullight" type="application/rss+xml">
</head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Gracefullight</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">Computer Scientist</h1></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>홈</a></li><li class="menu-item menu-item-about"><a href="/profile/" rel="section"><i class="fa fa-fw fa-user"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>태그</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>카테고리</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>아카이브</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>검색</a></li></ul></nav><div class="site-search"><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko"><link itemprop="mainEntityOfPage" href="https://gracefullight.dev/2017/01/29/%EC%A0%84%EC%9E%90%EA%B3%84%EC%82%B0%EA%B8%B0-%EA%B5%AC%EC%A1%B0-%EC%A0%95%EB%A6%AC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/profile_dog.png"><meta itemprop="name" content="Gracefullight"><meta itemprop="description" content="풀스택 개발자를 꿈꾸며"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Gracefullight"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">전자계산기 구조 정리</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">작성일</span> <time title="Post created: 2017-01-30 00:35:16" itemprop="dateCreated datePublished" datetime="2017-01-30T00:35:16+09:00">2017-01-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Updated at: 2020-03-15 23:22:42" itemprop="dateModified" datetime="2020-03-15T23:22:42+09:00">2020-03-15</time> </span><span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">Views: </span><span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Disqus: </span><a title="disqus" href="/2017/01/29/%EC%A0%84%EC%9E%90%EA%B3%84%EC%82%B0%EA%B8%B0-%EA%B5%AC%EC%A1%B0-%EC%A0%95%EB%A6%AC/#disqus_thread" itemprop="discussionUrl"><span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/01/29/전자계산기-구조-정리/" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="불-대수"><a class="markdownIt-Anchor" href="#불-대수"></a> 불 대수</h1><ul><li>영국 수학자 불에 의해 개발</li><li>AND : 입력 값이 모두 1일 때 1 출력</li><li>OR : 입력 값이 하나라도 1일 때 1 출력</li><li>NOT : 부정</li></ul><h2 id="기본-공식"><a class="markdownIt-Anchor" href="#기본-공식"></a> 기본 공식</h2><ul><li><strong>합의 곱을 곱의 합으로 변환</strong></li><li>분배법칙 예외 : A ＋(B×C) = (A ＋ B)(B ＋ C)</li><li>드모르강<ul><li>(A ＋ B)` = A`×B`</li><li>(A×B)` = A`＋ B`</li></ul></li><li>멱등<ul><li>A ＋ A = A</li><li>A×A = A</li></ul></li><li>보수<ul><li>A ＋ A` = 1</li><li>A×A` = 0</li></ul></li><li>항등<ul><li>A ＋ 0 = A</li><li>A ＋ 1 = 1</li><li>A×0 = 0</li><li>A×1 = A</li></ul></li><li>콘센서스<ul><li>AB ＋ BC ＋ CA` = AB ＋ CA`</li><li>(A ＋ B)(B ＋ C)(C ＋ A`) = (A ＋ B)(C ＋ A`)</li></ul></li><li>복원 : A`` = A</li><li>기타<ul><li>A ＋ A`B = A ＋ B</li><li>A ＋ AB = A</li></ul></li></ul><h2 id="카르노-맵"><a class="markdownIt-Anchor" href="#카르노-맵"></a> 카르노 맵</h2><ul><li>설계된 논리식을 도표로 표현하여 최소화 하는 방법</li><li>Karnaugh map = K-map = 카노맵</li></ul><p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b7/K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg/275px-K-map_6%2C8%2C9%2C10%2C11%2C12%2C13%2C14.svg.png" alt="카르노 맵"><br>AB와 CD의 위치를 바꾸어 계산하는게 쉽다.</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center"><strong>00</strong></td><td style="text-align:center"><strong>01</strong></td><td style="text-align:center"><strong>11</strong></td><td style="text-align:center"><strong>10</strong></td></tr><tr><td style="text-align:center"><strong>00</strong></td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center"><strong>01</strong></td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center"><strong>11</strong></td><td style="text-align:center">12</td><td style="text-align:center">13</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center"><strong>10</strong></td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">11</td></tr></tbody></table><h1 id="논리-게이트"><a class="markdownIt-Anchor" href="#논리-게이트"></a> 논리 게이트</h1><ul><li>BUFFER : 입력된 정보를 그대로 출력</li><li>NAND : NOT + AND</li><li>NOR : NOT + OR</li><li>XOR : 입력이 같으면 0, 다르면 1<ul><li>X = A⊕B</li><li>X = A`B + AB`</li><li>X = (A + B)(A` + B`)</li></ul></li><li>XNOR : NOT + XOR<ul><li>X = A⊙B</li><li>X = (A⊕B)`</li><li>X = AB + A`B`</li></ul></li></ul><h1 id="조합논리회로"><a class="markdownIt-Anchor" href="#조합논리회로"></a> 조합논리회로</h1><p>반가산기, 전가산기, 병렬가산기, 반감산기, 전감산기, 디코더, 인코더, 멀티플렉서, 디멀티플렉서, 다수결회로, 비교기 등</p><h2 id="반가산기"><a class="markdownIt-Anchor" href="#반가산기"></a> 반가산기</h2><p>2진수 두 개를 더한 합과 자리올림수를 구하는 조합논리회로</p><ul><li>합은 S, 자리올림(캐리)는 C</li><li>C = AB</li><li>S = A`B + AB` = A⊕B</li></ul><h2 id="전가산기"><a class="markdownIt-Anchor" href="#전가산기"></a> 전가산기</h2><p>1bit 2진수 3자리를 더하여 합과 자리올림수를 구하는 조합논리회로</p><ul><li>두 개의 반가산기와 한 개의 OR GATE로 구성</li><li>합은 S, 자리올림(캐리)는 C</li><li>C = (A⊕B)C + AB</li><li>S = (A⊕B)⊕C</li><li>3 × 8 디코더 1개 + 4 입력 OR 게이트 2개로 구성가능</li></ul><h2 id="병렬가산기"><a class="markdownIt-Anchor" href="#병렬가산기"></a> 병렬가산기</h2><p>n bit로 된 2진수 A, B에 대한 덧셈을 n개의 전가산기를 이용하여 구현한 실질적인 가산기</p><ul><li>전파지연을 줄이기 위해 Carry Look Ahead 사용</li><li>전파지연 : ALU Path에서 가장 긴 Delay</li></ul><h2 id="반감산기"><a class="markdownIt-Anchor" href="#반감산기"></a> 반감산기</h2><p>1bit 2진수 2자리에 대한 감산을 하는 조합논리회로</p><ul><li>차는 D, 빌려온 수는 B</li><li>B = A`B</li><li>D = A`B + A`B = A⊕B</li><li>2 × 4 디코더 1개 + 3 입력 OR 게이트 1개로 구성가능</li></ul><h2 id="디코더"><a class="markdownIt-Anchor" href="#디코더"></a> 디코더</h2><p>n bit의 코드화된 정보를 그 코드의 각 bit 조합에 따라 2^n개의 출력으로 번역하는 조합논리회로</p><ul><li><strong>n개의 입력을 2^n개의 출력으로</strong></li><li>명령어의 명령부나 번지를 해독할 때 사용</li><li>주로 AND 게이트로 구성</li><li>부호화된 데이터에서 정보를 찾아냄</li><li>n × 2^n 디코더의 AND 게이트 수 : 2^n 개<ul><li>5 × 8 디코더 : 8개</li></ul></li></ul><h2 id="인코더"><a class="markdownIt-Anchor" href="#인코더"></a> 인코더</h2><p>2^n개의 입력선으로 입력된 값을 n개의 출력선으로 코드화해서 출력하는 조합논리회로</p><ul><li><strong>2^n개의 입력을 n개의 출력으로</strong><ul><li>16개의 입력선일 경우 4개의 출력선 필요 (2^4)</li></ul></li></ul><h2 id="멀티플렉서"><a class="markdownIt-Anchor" href="#멀티플렉서"></a> 멀티플렉서</h2><p>2^n개의 입력선 중 1개를 <strong>선택</strong>하여 그 선에서 입력되는 값을 1개의 출력선으로 출력하는 조합논리회로</p><ul><li>2^n개의 입력선 중 1개의 선을 선택하기 위해 <strong>n개의 선택선 이용</strong><ul><li>16개의 입력선일 경우 4개의 선택선 필요 (2^4)</li><li><strong>출력선은 하나</strong></li></ul></li></ul><h2 id="디멀티플렉서"><a class="markdownIt-Anchor" href="#디멀티플렉서"></a> 디멀티플렉서</h2><p>1개의 입력선으로 들어오는 데이터를 2^n개의 출력선 중 1개를 선택하여 출력하는 회로</p><ul><li>2^n개의 출력선 중 1개의 선을 선택하기 위해 <strong>n개의 선택선 이용</strong></li><li>16개의 출력선일 경우 4개의 선택선 필요 (2^4)</li><li><strong>입력선은 하나</strong></li></ul><h1 id="순서논리회로"><a class="markdownIt-Anchor" href="#순서논리회로"></a> 순서논리회로</h1><ul><li>외부의 입력과 현재 상태에 따라 출력이 결정</li><li>논리 게이트 외에 메모리 요소와 피드백 기능을 포함</li><li>기억기능 존재</li><li>출력이 일정한 값을 갖지 않음</li><li><strong>플리플롭과 논리 게이트로 구성</strong></li><li>동기식과 비동기식으로 나뉨</li><li><strong>플리플롭, 카운터, 레지스터, RAM, CPU</strong> 등</li></ul><h2 id="플리플롭"><a class="markdownIt-Anchor" href="#플리플롭"></a> 플리플롭</h2><ul><li>전원이 공급되는한 상태의 변화를 위한 외부신호가 발생할 때까지 현재의 상태를 그대로 유지하는 논리회로</li><li>레지스터, 카운터, 반도체메모리(RAM)의 기본 구성요소</li><li>2진수 1bit를 저장 가능</li><li>두 개의 NAND 또는 두 개의 NOR 게이트를 이용하여 구성</li></ul><h3 id="특성표"><a class="markdownIt-Anchor" href="#특성표"></a> 특성표</h3><p>순서논리회로의 기능을 나타내는 표로 입력선의 값에 따라 현재 상태가 다음 상태로 어떻게 변하여 저장되는지를 나타낸다.</p><h3 id="여기표"><a class="markdownIt-Anchor" href="#여기표"></a> 여기표</h3><p>특성표 대신 순서논리회로의 기능을 표로 나타낸 것, 현재 상태 값을 새로운 값으로 변경시키려면 입력선으로 어떤 값을 입력해야 하는가를 나타낸다.<br>출력을 이용하여 입력을 알아내는 것.</p><h3 id="rs-플립플롭"><a class="markdownIt-Anchor" href="#rs-플립플롭"></a> RS 플립플롭</h3><ul><li>Reset-Set FF</li><li>특성표</li></ul><table><thead><tr><th style="text-align:center">S</th><th style="text-align:center">R</th><th style="text-align:center">Q</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">無</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">不可</td></tr></tbody></table><ul><li>여기표는 특성표를 떠올리면 구할 수 있다.</li></ul><h3 id="d-플립플롭"><a class="markdownIt-Anchor" href="#d-플립플롭"></a> D 플립플롭</h3><ul><li>RS 플리플롭의 R선에 인버터(NOT 연산자)를 추가하여 S선과 하나로 묶어서 입력선을 하나만 구성한 플립플롭</li><li>입력값을 그대로 저장하는 기능을 수행</li><li>특성표</li></ul><table><thead><tr><th style="text-align:center">D</th><th style="text-align:center">Q</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table><h3 id="jk-플립플롭"><a class="markdownIt-Anchor" href="#jk-플립플롭"></a> JK 플립플롭</h3><ul><li>RS에서 S=1, R=1일 때 동작하지 않는 점을 보완한 플립플롭</li><li>RS 플립플롭의 입력선 S와 R에 <strong>AND 게이트 2개</strong>를 추가하여 JK 플립플롭의 입력선 J와 K로 사용한다.</li><li>모든 플립플롭의 기능을 포함한다.</li><li>플립플롭의 네가지 기능을 모두 갖춘 것을 찾으라는 문제가 나오면 RS가 있으면 RS, JK가 있으면 JK</li><li>특성표</li></ul><table><thead><tr><th style="text-align:center">S</th><th style="text-align:center">R</th><th style="text-align:center">Q</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">無</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">보수</td></tr></tbody></table><ul><li>여기표는 특성표를 떠올리면 구할 수 있다.</li></ul><h3 id="t-플립플롭"><a class="markdownIt-Anchor" href="#t-플립플롭"></a> T 플립플롭</h3><ul><li>JK 플립플롭의 두 입력선을 묶어서 한 개의 입력선으로 구성한 플립플롭</li><li>T=1인 경우 현재 상태를 토글한다. <strong>보수가 출력</strong>된다.</li><li>카운터에 이용</li></ul><table><thead><tr><th style="text-align:center">T</th><th style="text-align:center">Q</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">無</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">보수</td></tr></tbody></table><h3 id="ms-플립플롭"><a class="markdownIt-Anchor" href="#ms-플립플롭"></a> M/S 플립플롭</h3><ul><li>마스터-슬레이브 플립플롭</li><li>출력 측의 일부가 입력 측에 피드백되어 유발되는 레이스 현상을 없애기 위해 고안된 플립플롭</li><li>두 개의 플립플롭으로 구성</li><li>레이스 현상 : 입력이 되는 조합회로의 출력을 플리플롭이 받는 동안 플리플롭의 내부 상태가 변하고 있으면 그 상태값이 피드백통로를 통해 조합회로로 전달되므로 회로가 불안정해지는 현상</li></ul><h1 id="자료-구성-단위"><a class="markdownIt-Anchor" href="#자료-구성-단위"></a> 자료 구성 단위</h1><h2 id="비트"><a class="markdownIt-Anchor" href="#비트"></a> 비트</h2><ul><li>자료, 정보 표현의 최소 단위</li><li>0과 1을 표시하는 2진수 1자리</li></ul><h2 id="니블"><a class="markdownIt-Anchor" href="#니블"></a> 니블</h2><ul><li>4bit가 모여 구성</li><li>16진수 1자리를 표현하기에 적합</li></ul><h2 id="바이트"><a class="markdownIt-Anchor" href="#바이트"></a> 바이트</h2><ul><li><strong>문자를 표현하는 최소 단위</strong></li><li>8bit가 모여 1Byte</li><li>1Byte는 256가지의 정보를 표현(2^8bit)</li><li>Alphanumeric은 1Byte, 한글한자는 2Byte</li><li>KB = 2의 10승, MB = 2의 20승…</li></ul><h2 id="워드"><a class="markdownIt-Anchor" href="#워드"></a> 워드</h2><ul><li>컴퓨터가 한 번에 처리할 수 있는 명령 단위</li><li><strong>전워드 : 4Byte</strong> (full word)</li><li>하프워드 : 2Byte (반워드)</li><li>더블워드 : 8Byte</li></ul><h2 id="필드"><a class="markdownIt-Anchor" href="#필드"></a> 필드</h2><ul><li>파일 구성의 최소 단위</li><li>의미 있는 정보를 표현하는 최소 단위</li></ul><h2 id="레코드"><a class="markdownIt-Anchor" href="#레코드"></a> 레코드</h2><ul><li>하나 이상의 관련된 필드가 모여서 구성</li><li>컴퓨터 내부 자료 처리 단위</li><li><strong>논리 레코드</strong>를 의미</li></ul><h2 id="블록"><a class="markdownIt-Anchor" href="#블록"></a> 블록</h2><ul><li><strong>물리 레코드</strong></li><li>하나 이상의 논리 레코드가 모여서 구성</li><li>각종 저장 매체와의 입출력 단위를 의미</li></ul><h2 id="파일"><a class="markdownIt-Anchor" href="#파일"></a> 파일</h2><ul><li>프로그램 구성의 기본 단위</li><li>같은 종류의 여러 레코드가 모여서 구성</li></ul><h2 id="데이터베이스"><a class="markdownIt-Anchor" href="#데이터베이스"></a> 데이터베이스</h2><ul><li>여러 개의 관련된 파일의 집합</li><li>관계형, 계층형, 망형 DB</li></ul><h1 id="진법"><a class="markdownIt-Anchor" href="#진법"></a> 진법</h1><h2 id="2진수"><a class="markdownIt-Anchor" href="#2진수"></a> 2진수</h2><p>정수는 나누고 소숫점은 곱하고</p><h2 id="8진수"><a class="markdownIt-Anchor" href="#8진수"></a> 8진수</h2><p>2진수를 구하고 3자리씩 묶고</p><h2 id="16진수"><a class="markdownIt-Anchor" href="#16진수"></a> 16진수</h2><p>2진수를 구하고 4자리씩 묶고</p><h1 id="보수"><a class="markdownIt-Anchor" href="#보수"></a> 보수</h1><ul><li>덧셈회로를 이용하여 뺄셈을 수행하기 위해 사용</li><li>1의 보수 : 그냥 반전</li><li>2의 보수<ul><li>1의 보수를 구한 뒤 1을 더함</li><li>뒤에서부터 1이 나올때까지는 그냥쓰고 나머지는 반전</li></ul></li></ul><h2 id="뺄셈"><a class="markdownIt-Anchor" href="#뺄셈"></a> 뺄셈</h2><ul><li>1의 보수 이용 : 자리올림이 발생하면 결과에 자리올림수를 더한다.</li><li>2의 보수 이용 : 자리올림이 발생하면 버린다.</li></ul><h1 id="고정-소수점"><a class="markdownIt-Anchor" href="#고정-소수점"></a> 고정 소수점</h1><p>정수 데이터 표현 및 연산에 사용하는 방법</p><h2 id="2진연산"><a class="markdownIt-Anchor" href="#2진연산"></a> 2진연산</h2><ul><li>정수값을 2진수로 변환하여 표현하는 방식</li><li>표현할 수 있는 범위가 작음</li><li>연산속도 빠름</li><li>맨처음 1bit는 부호비트로 사용</li></ul><h3 id="음수연산"><a class="markdownIt-Anchor" href="#음수연산"></a> 음수연산</h3><ul><li>부호화 절대치법 : 양수 표현에 대해 부호비트만 바꾼다.</li><li>부호화 1의 보수법 : 양수 표현에 대해 1의 보수를 구한다.</li><li>부호화 2의 보수법 : 양수 표현에 대해 2의 보수를 구한다.<ul><li>1의 보수 표현법에 비해 음수 1개를 더 표현할 수 있다.</li><li>자리올림을 무시하므로 1의 보수 표현에 비해 연산이 간단하다.</li><li>0이 하나만 존재한다.</li></ul></li></ul><blockquote><p><strong>부호화 2진 표현을 10진수로 변경시</strong></p><ol><li>부호 비트를 빼고 2의 보수 연산</li><li>부호를 대입</li></ol></blockquote><h2 id="10진연산"><a class="markdownIt-Anchor" href="#10진연산"></a> 10진연산</h2><h3 id="언팩연산"><a class="markdownIt-Anchor" href="#언팩연산"></a> 언팩연산</h3><ul><li>존형 10진연산 = Zone Decimal</li><li><strong>연산이 불가능</strong>하다.</li><li><strong>데이터 입출력에 사용</strong></li><li>1Byte로 10진수 1자리를 표현</li><li>4개의 존 비트와 4개의 숫자 비트를 사용</li><li><strong>최하위 바이트의 존 부분을 부호로 사용</strong></li><li>Zone = F, Digit = 4Bit 2진수</li><li>Sign = 양수 C, 음수 D, 부호 없는 양수 F</li></ul><h3 id="팩연산"><a class="markdownIt-Anchor" href="#팩연산"></a> 팩연산</h3><ul><li><strong>연산이 가능</strong></li><li><strong>데이터 입출력 불가능</strong></li><li>1Byte로 10진수 2자리를 표현</li><li><strong>최하위 바이트의 마지막 4Bit를 부호로 사용</strong></li><li>Digit = 4Bit 2진수</li><li>Sign = 양수 C, 음수 D, 부호 없는 양수 F</li></ul><h1 id="부동소수점"><a class="markdownIt-Anchor" href="#부동소수점"></a> 부동소수점</h1><ul><li>매우 크거나 작은 수, 매우 정밀한 수를 적은 비트로 표현 가능</li><li>연산시간이 느림</li><li>부동 소수점의 연산 수행횟수를 FLOPS로 표시<ul><li><strong>FLOPS</strong> : FLoating point Operations Per Second, 컴퓨터 연산속도의 단위</li></ul></li><li>지수부와 가수부를 분리하는 <strong>정규화</strong> 과정 필요<br><strong>정규화</strong> : 0.1 &lt;= 가수부분 &lt; 1 을 만족시키게 변경</li><li>4Byte를 사용하는 단정도와 8Byte를 사용하는 배정도 표현법</li><li>지수부에는 정규화해서 분리한 지수값을 <strong>64Bias</strong>법으로 표현<ul><li>64Bias : 지수 7Bit에 100 0000이 입력되어 있고 2^n의 n만큼을 더하고 뺴서 지수를 표현하는 방식</li></ul></li></ul><h2 id="ieee-표준"><a class="markdownIt-Anchor" href="#ieee-표준"></a> IEEE 표준</h2><ul><li>IEEE 754 표준</li><li>정규화시 가수부가 1이되게 정규화</li><li><strong>127Bais</strong>를 사용해 지수 8Bit에 0111 1111이 들어있음</li></ul><table><thead><tr><th style="text-align:center">구분</th><th style="text-align:center">크기</th><th style="text-align:center">부호</th><th style="text-align:center">지수</th><th style="text-align:center">가수</th></tr></thead><tbody><tr><td style="text-align:center">single</td><td style="text-align:center"><strong>32</strong></td><td style="text-align:center">1</td><td style="text-align:center"><strong>8</strong></td><td style="text-align:center">23</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center"><strong>64</strong></td><td style="text-align:center">1</td><td style="text-align:center"><strong>11</strong></td><td style="text-align:center">52</td></tr><tr><td style="text-align:center">extended</td><td style="text-align:center">80</td><td style="text-align:center">1</td><td style="text-align:center">11</td><td style="text-align:center">68</td></tr></tbody></table><h2 id="연산"><a class="markdownIt-Anchor" href="#연산"></a> 연산</h2><h3 id="덧셈-및-뺄셈"><a class="markdownIt-Anchor" href="#덧셈-및-뺄셈"></a> 덧셈 및 뺄셈</h3><ol><li>0인지 확인</li><li>지수가 큰쪽에 수를 맞추어 정규화</li><li>연산</li><li>결과 정규화</li></ol><h3 id="곱셈"><a class="markdownIt-Anchor" href="#곱셈"></a> 곱셈</h3><ol><li>0인지 확인</li><li>지수 덧셈</li><li>가수 곱셈</li><li>결과 정규화</li></ol><h3 id="나눗셈"><a class="markdownIt-Anchor" href="#나눗셈"></a> 나눗셈</h3><ol><li>0인지 확인</li><li>레지스터 초기화</li><li>부호 결정</li><li>나눠지는 수가 나누는 수보다 작게 나눠지는 수를 정규화</li><li>지수 뺄셈</li><li>가수 나눗셈</li></ol><h1 id="자료-표현"><a class="markdownIt-Anchor" href="#자료-표현"></a> 자료 표현</h1><h2 id="bcd"><a class="markdownIt-Anchor" href="#bcd"></a> BCD</h2><ul><li>2진화 10진코드 = Binary Coded Decimal</li><li>6Bit 코드로 IBM에서 개발</li><li>1개의 문자를 2개의 Zone Bit와 4개의 Digit Bit로 표현</li><li>6Bit이므로 64개 문자 표현 가능</li><li>1Bit의 Parity Bit를 추가해 <strong>7Bit로 사용</strong></li><li><strong>영소문자 표현 불가</strong></li></ul><h2 id="ascii"><a class="markdownIt-Anchor" href="#ascii"></a> ASCII</h2><ul><li>American Standard Code for Information Interchange</li><li>7Bit 코드로 미국 표준협회에서 개발</li><li>7Bit이므로 128개의 문자 표현 가능</li><li>1Bit의 Parity Bit를 추가해 <strong>8Bit로 사용</strong></li><li><strong>영대소문자, 숫자, 제어문자, 특수문자 등 표현 가능</strong></li><li>통신 제어용 및 마이크로 컴퓨터의 기본코드로 사용</li></ul><h2 id="ebcdic"><a class="markdownIt-Anchor" href="#ebcdic"></a> EBCDIC</h2><ul><li>8Bit 코드로 IBM에서 개발</li><li>1개의 문자를 4개의 Zone Bit와 4개의 Digit Bit로 표현</li><li>8Bit이므로 256개의 문자 표현 가능</li><li>1Bit의 Parity Bit를 추가해 <strong>9Bit로 사용</strong></li><li><strong>특수문자, 영대소문자, 숫자 등 표현 가능</strong></li></ul><h2 id="bcd-코드"><a class="markdownIt-Anchor" href="#bcd-코드"></a> BCD 코드</h2><ul><li>10진수 1자리를 2진수 4Bit로 표현</li><li><strong>8421 코드</strong></li><li><strong>가중치 코드</strong><ul><li>2진수 각 자리가 고유한 값을 가지는 코드</li></ul></li><li>BCD에서 Zone을 생략한 형태</li><li>10진수 입출력이 간편</li></ul><h2 id="excess3-코드"><a class="markdownIt-Anchor" href="#excess3-코드"></a> Excess3 코드</h2><ul><li>BCD 코드에 3을 더하여 만든 코드</li><li>모든 비트가 동시에 0이 되는 경우가 없다.</li><li><strong>3 초과 코드</strong></li><li><strong>자기보수 코드</strong></li><li><strong>비가중치 코드</strong></li><li>10진수를 표현하기 위함이다.</li><li>보수를 구하기 편해 산술연산에 좋다.</li></ul><h2 id="gray-코드"><a class="markdownIt-Anchor" href="#gray-코드"></a> Gray 코드</h2><ul><li>BCD 코드의 인접하는 Bit를 XOR 연산하여 만든 코드</li><li>코드 변환이 용이</li><li>입출력장치, A/D변환기, 주변장치 등에서 숫자를 표현할 때 사용</li><li>1Bit만 변화시켜 다음 수치로 증가시키기 때문에 하드웨어 오류가 적다.</li><li>2진수를 Gray로 변경시 : n자 모양으로 연산<ul><li>첫번째 그레이 비트는 2진수 첫번째 비트 그대로</li><li>2진수 비트를 앞뒤로 XOR 연산</li></ul></li><li>Gray를 2진수로 변경시 : h자 모양으로 연산<ul><li>첫번째 2진수는 그레이 비트 그대로</li><li>두번째부턴 왼쪽 변경된 2진수와 변경할 우측 그레이 비트를 XOR 연산</li></ul></li></ul><h2 id="패리티-코드"><a class="markdownIt-Anchor" href="#패리티-코드"></a> 패리티 코드</h2><ul><li>전송된 코드의 오류를 검사하기 위해 데이터 비트 외에 1Bit의 패리티 체크 비트를 추가하는 것</li><li>1Bit의 오류만 검출 가능</li></ul><h3 id="홀수-패리티"><a class="markdownIt-Anchor" href="#홀수-패리티"></a> 홀수 패리티</h3><ul><li>Odd Parity = 기수 패리티</li><li>1의 갯수가 홀수가 되도록 0이나 1을 마지막에 추가</li></ul><h3 id="짝수-패리티"><a class="markdownIt-Anchor" href="#짝수-패리티"></a> 짝수 패리티</h3><ul><li>Even Parity = 우수 패리티</li><li>1의 갯수가 짝수가 되도록 0이나 1을 마지막에 추가</li></ul><h2 id="해밍-코드"><a class="markdownIt-Anchor" href="#해밍-코드"></a> 해밍 코드</h2><ul><li>오류를 검출하고 교정이 가능한 코드</li><li>2Bit의 오류를 검출할 수 있고 1Bit를 교정 가능</li><li>잉여비트가 많이 필요</li><li>1, 2, 4, 8, … <strong>2^n번째 Bit는 오류 검출을 위한 패리티 비트</strong></li><li>패리티 비트 결정시<ul><li>1번 Bit는 1, 3, 5, 7…</li><li>2번 Bit는 2, 3, 6, 7, 10, 11… 2Bit씩 건너 뛰면서</li><li>4번 Bit는 4, 5, 6, 7, 12, 13, 14, 15… 4Bit씩 건너 뛰면서</li></ul></li></ul><h2 id="코드-분류"><a class="markdownIt-Anchor" href="#코드-분류"></a> 코드 분류</h2><p>가중치코드는 일반적으로 숫자로 이루어져 있다.</p><table><thead><tr><th style="text-align:center">분류</th><th style="text-align:center">코드종류</th></tr></thead><tbody><tr><td style="text-align:center">가중치</td><td style="text-align:center">BCD(8421), 2421, 84-2-1, Biquinary, 51111, RingCounter</td></tr><tr><td style="text-align:center">비가중치</td><td style="text-align:center">3초과(Excess3), Gray, Jonson, 2outof5, 3outof5</td></tr><tr><td style="text-align:center">자기보수</td><td style="text-align:center">3초과(Excess3), 2421, 51111, 84-2-1</td></tr><tr><td style="text-align:center">오류검출</td><td style="text-align:center">해밍, 패리티, Biquinary, RingCounter, 2outof5, 3outof5</td></tr></tbody></table><h1 id="중앙처리장치"><a class="markdownIt-Anchor" href="#중앙처리장치"></a> 중앙처리장치</h1><p><strong>제어장치, 연산장치, 레지스터, 버스</strong>로 구성</p><h2 id="제어장치"><a class="markdownIt-Anchor" href="#제어장치"></a> 제어장치</h2><ul><li>컴퓨터의 모든 장치에 대한 동작을 지시하고 제어</li><li>명령 레지스터에서 읽어들인 명령어를 해독해 장치에 제어신호를 보내 명령을 수행하도록 지시</li><li>제어장치에 입력되는 항목<ul><li>명령어 레지스터</li><li>플래그</li><li>클록</li></ul></li></ul><h3 id="구성요소"><a class="markdownIt-Anchor" href="#구성요소"></a> 구성요소</h3><ul><li>명령 레지스터 : 현재 실행중인 명령어 내용 기억</li><li>명령 해독기(디코더) : 명령 레지스터에 있는 명령어를 해독</li><li>제어 발생기(인코더) : 해독된 명령에 따라 각 장치로 본래 제어 신호 생성</li><li>제어 주소 레지스터(CAR) : 다음에 실행할 마이크로 명령어의 주소를 저장하는 레지스터<ul><li>매핑의 결과값, 주소필드, 서브루틴 레지스터의 내용이 기록</li></ul></li><li>제어 버퍼 레지스터(CBR) : 제어 기억장치로부터 읽혀진 마이크로명령어를 일시적으로 저장하는 레지스터</li><li>제어 기억장치 : 마이크로 프로그램을 저장하는 내부 기억장치</li><li>순서 제어모듈 : 마이크로 명령어의 실행 순서를 결정하는 회로집합</li><li>순차 카운터 : 디코더에 의해 선택된 번호에 해당하는 타이밍 신호를 생성</li></ul><h2 id="연산장치"><a class="markdownIt-Anchor" href="#연산장치"></a> 연산장치</h2><ul><li>제어장치에 명령에 따라 실제로 연산을 수행하는 장치</li><li>산술연산, 논리연산, 관계연산, Shift 등</li><li>가산기, 누산기(AC), 보수기(Complementor), 데이터레지스터, 오버플로 검출기, 시프트 레지스터 등</li></ul><h2 id="레지스터"><a class="markdownIt-Anchor" href="#레지스터"></a> 레지스터</h2><ul><li>CPU 내부에서 처리할 명령어나 연산의 중간 결과값 등을 일시적으로 기억하는 임시 기억장소</li><li>플리플롭이나 래치들을 병렬로 연결하여 구성</li><li>메모리 중에서 속도가 가장 빠르다.</li><li>레지스터의 크기는 워드를 구성하는 비트 개수만큼의 플립플롭으로 구성<ul><li>워드의 크기가 16Bit =&gt; 레지스터는 16개의 플립플롭이나 래치로 구성</li></ul></li><li>저장값을 0으로 하는 것을 설정해제(CLR)</li></ul><h3 id="자료전송"><a class="markdownIt-Anchor" href="#자료전송"></a> 자료전송</h3><ul><li>직렬 전송 : 직렬 시프트 마이크로 오퍼레이션, 느림</li><li>병렬 전송 : 하나의 클록펄스 동안 워드가 동시에 전송</li><li>버스 전송 : 모든 레지스터가 공통으로 이용하는 경로, 병렬에 비해 결선의 수를 줄일 수 있다.</li></ul><h3 id="주요-레지스터"><a class="markdownIt-Anchor" href="#주요-레지스터"></a> 주요 레지스터</h3><ul><li><strong>PC</strong> : 프로그램 카운터, 다음번 실행할 명령어의 번지를 기억하는 레지스터로 분기 명령이 실행되는 경우 그 목적지 주소로 갱신</li><li><strong>IR</strong> : 명령레지스터, 현재 실행중인 명령의 내용을 기억하는 레지스터</li><li><strong>AC</strong> : 누산기, 연산된 결과를 일시적으로 저장하는 레지스터</li><li><strong>PSWR</strong> : <strong>Status Register, Program Status Word Register, Flag Regiester</strong><ul><li>시스템 내부의 순간 상태가 기록된 정보를 PSW라 한다.</li><li>오버플로, 언더플로, 자리올림, 계산상태, 인터럽트 등의 PSW를 저장하는 레지스터</li><li>프로그램 제어와 밀접한 관계</li></ul></li><li><strong>MAR</strong> : 메모리 주소 레지스터, 데이터의 번지를 기억하는 레지스터</li><li><strong>MBR</strong> : 메모리 버퍼 레지스터, 데이터가 잠시 기억되는 레지스터, CPU가 데이터를 처리하기 위해서 반드시 거처야한다.</li><li>Base Register : 명령이 시작되는 시작 번지를 기억하는 레지스터</li><li>Index Register : 주소의 변경, 서브루틴 연결 및 프로그램에서의 반복연산의 횟수를 세는 레지스터로 프로그래머가 내용을 변경할 수 있다.</li><li>Data Register : 연산에 사용될 데이터를 기억하는 레지스터</li><li>Shift Register : 저장된 값을 미는 연산을 하는 레지스터, 2배 길이 레지스터</li><li>Major Status Register : CPU의 현재상태(인출, 간접, 실행, 인터럽트)를 저장하고 있는 레지스터</li></ul><h2 id="버스"><a class="markdownIt-Anchor" href="#버스"></a> 버스</h2><ul><li>CPU, 메모리, I/O장치와 상호 필요한 정보를 교환하기 위해 연결하는 전송선</li><li>내부회로에서 버스를 사용하는 목적은 결선의 수를 줄이기 위해서다.</li></ul><h3 id="종류"><a class="markdownIt-Anchor" href="#종류"></a> 종류</h3><ul><li><p><strong>제어 버스</strong> : Control Bus, <strong>양방향 전송선</strong>, 제어신호 전송</p></li><li><p><strong>주소 버스</strong> : Address Bus, 번지 버스, <strong>단방향 전송선</strong>, 번지 지정</p></li><li><p><strong>데이터 버스</strong> : Data Bus, 자료 버스, <strong>양방향 전송선</strong>, 데이터 전송</p></li><li><p>내부버스 : CPU 및 메모리에 구성된 버스</p></li><li><p>외부버스 : 주변 I/O장치에 구성된 버스</p></li></ul><h1 id="명령어"><a class="markdownIt-Anchor" href="#명령어"></a> 명령어</h1><p>OP code부, Mode부, Operand부로 구성</p><h2 id="연산자부"><a class="markdownIt-Anchor" href="#연산자부"></a> 연산자부</h2><ul><li>Operation Code부 = OP Code</li><li>연산자부의 크기는 표현할 수 있는 명령의 종류를 나타내는 것</li><li>nBit일 때 최대 2^n의 명령어 표현 가능</li></ul><h2 id="모드부"><a class="markdownIt-Anchor" href="#모드부"></a> 모드부</h2><ul><li>Mode부</li><li>주소부의 유효 주소가 결정되는 방법을 지정</li><li>0이면 직접, 1이면 간접</li></ul><h2 id="자료부"><a class="markdownIt-Anchor" href="#자료부"></a> 자료부</h2><ul><li>Operand부 = 오퍼랜드부 = 주소필드</li><li>실제 데이터에 대한 정보를 표시하는 부분</li><li>주소, 레지스터 번호, 사용할 데이터 등을 표시</li><li>자료부의 크기는 메모리 용량과 관계가 있다.</li></ul><h2 id="설계시-고려사항"><a class="markdownIt-Anchor" href="#설계시-고려사항"></a> 설계시 고려사항</h2><ul><li>연산자의 종류</li><li>명령어 형식</li><li>주소지정방식</li><li>데이터 구조</li><li>효율성 제고방안 : 기억공간, 사용빈도, 주소지정방식, 주기억장치의 대역폭 이용</li></ul><h2 id="기능"><a class="markdownIt-Anchor" href="#기능"></a> 기능</h2><p>함수 연산, 자료전달, 제어, 입출력 기능</p><h3 id="함수-연산-기능"><a class="markdownIt-Anchor" href="#함수-연산-기능"></a> 함수 연산 기능</h3><ul><li><p>산술연산 : ADD, SUB, MUL, DIV, 산술 Shift</p></li><li><p>논리연산 : NOT, AND, OR, XOR, 논리 Shift, Rotate, Complement, Clear</p></li><li><p>단항연산 : NOT, Complement, Shift, Rotate, Move</p></li><li><p>이항연산 : 사칙, AND, OR, XOR, XNOR</p></li><li><p>연산자 우선순위</p><ol><li>산술연산자 : 거듭제곱 &gt; 곱=나눔 &gt; 덧,뺄</li><li>관계연산자</li><li>논리 연산자 : NOT &gt; AND &gt; OR</li></ol></li></ul><h3 id="자료-전달-기능"><a class="markdownIt-Anchor" href="#자료-전달-기능"></a> 자료 전달 기능</h3><ul><li>Load : 기억장치 =&gt; CPU</li><li>Store : CPU =&gt; 기억장치 저장</li><li>Move : 레지스터간 자료 전송</li><li>Push : 스택에 자료 저장</li><li>Pop : 스택에서 자료 꺼냄</li></ul><h3 id="제어-기능"><a class="markdownIt-Anchor" href="#제어-기능"></a> 제어 기능</h3><ul><li>무조건 분기 : GOTO, JMP (PC &lt;- X)</li><li>조건 분기 : IF, SPA, SNA, SZA<ul><li>SPA : Skip if AC is Positive</li><li>SNA : Skip if AC is Negative</li><li>SZA : Skip if AC is Zero</li></ul></li><li>Call : 부 프로그램 호출</li><li>Return : 부 프로그램에서 복귀</li></ul><h3 id="입출력-기능"><a class="markdownIt-Anchor" href="#입출력-기능"></a> 입출력 기능</h3><ul><li>Input</li><li>Output</li></ul><h1 id="연산-2"><a class="markdownIt-Anchor" href="#연산-2"></a> 연산</h1><h2 id="and"><a class="markdownIt-Anchor" href="#and"></a> AND</h2><ul><li>특정 비트를 삭제(Clear)하는 연산</li><li>Masking 연산</li></ul><h2 id="or"><a class="markdownIt-Anchor" href="#or"></a> OR</h2><ul><li>특정 비트를 1로 만드는 연산</li><li>Selective Set 연산</li></ul><h2 id="xor"><a class="markdownIt-Anchor" href="#xor"></a> XOR</h2><ul><li>두 개의 데이터를 비교하거나 특정 비트를 반전시킬 때 사용</li><li>결과에 1Bit라도 1이 있으면 서로 다른 데이터</li><li>반전시킬 Bit를 1과 XOR</li></ul><h2 id="not"><a class="markdownIt-Anchor" href="#not"></a> NOT</h2><ul><li>그냥 반전</li></ul><h2 id="논리-shift"><a class="markdownIt-Anchor" href="#논리-shift"></a> 논리 Shift</h2><ul><li>0을 삽입해 비트를 좌우로 한칸씩 민다.</li></ul><h2 id="rotate"><a class="markdownIt-Anchor" href="#rotate"></a> Rotate</h2><ul><li>Shift에서 밀려나간 비트를 반대편으로 가져와 입력하는 연산</li><li><strong>문자 위치를 변환할 때</strong> 사용</li></ul><h2 id="산술-shift"><a class="markdownIt-Anchor" href="#산술-shift"></a> 산술 Shift</h2><ul><li>부호를 고려하여 자리를 이동시키는 연산</li><li>2^n으로 곱하거나 나눌 때 사용</li><li>왼쪽으로 Shift시 2^n을 곱한 값과 같음</li><li>오른쪽으로 Shift시 2^n을 나눈 값과 같음</li><li>홀수를 오른쪽으로 Shift시에 0.5의 오차 발생</li><li>정수 표현 방식에서만 사용 가능</li><li>정수 수치 표현 방법에 따라 Padding Bit 및 결과가 다름</li></ul><h3 id="shift-left"><a class="markdownIt-Anchor" href="#shift-left"></a> Shift Left</h3><ul><li>부호화 절대치, 2의 보수법은 무조건 0</li><li>1의 보수법은 부호 비트와 같은 0, 1</li></ul><h3 id="shift-right"><a class="markdownIt-Anchor" href="#shift-right"></a> Shift Right</h3><ul><li>부호화 절대치는 0</li><li>1의 보수법, 2의 보수법은 부호 비트와 같은 0, 1</li></ul><h1 id="명령어-형식"><a class="markdownIt-Anchor" href="#명령어-형식"></a> 명령어 형식</h1><h2 id="3주소-명령어"><a class="markdownIt-Anchor" href="#3주소-명령어"></a> 3주소 명령어</h2><ul><li>Operand부가 세 개로 구성되는 명령어 형식</li><li>**GPR(범용 레지스터)**를 가진 컴퓨터에서 사용</li><li>연산의 결과는 Operand 1에 주로 기록 (컴퓨터에 따라 Operand 3에도 기록)</li></ul><h3 id="장점"><a class="markdownIt-Anchor" href="#장점"></a> 장점</h3><ul><li>연산시 원래 자료를 파괴하지 않음</li><li>다른 형식의 명령어를 이용하는 것보다 프로그램 전체의 길이가 짧음</li><li>전체 프로그램 실행시 명령인출을 위해 주기억장치를 접근하는 횟수 감소</li></ul><h3 id="단점"><a class="markdownIt-Anchor" href="#단점"></a> 단점</h3><ul><li>명령어 한 개의 길이가 너무 길어짐</li><li>하나의 명령을 수행하기 위해 최소한 4번 기억장소에 접근해야함</li><li>수행시간이 길다.</li></ul><h2 id="2주소-명령어"><a class="markdownIt-Anchor" href="#2주소-명령어"></a> 2주소 명령어</h2><ul><li>Operand가 두 개로 구성되는 일반적인 명령어 형식</li><li>여러 개의 **GPR(범용 레지스터)**를 가진 컴퓨터에서 사용</li></ul><h3 id="장점-2"><a class="markdownIt-Anchor" href="#장점-2"></a> 장점</h3><ul><li>실행 속도가 빠르고 기억장소를 많이 차지하지 않음</li><li>3주소 명령에 비해 명령어의 길이가 짧음</li><li>계산결과가 기억장치에 기억되고 CPU에도 남아 있어 계산 결과를 시험할 때 시간이 절약된다.</li></ul><h3 id="단점-2"><a class="markdownIt-Anchor" href="#단점-2"></a> 단점</h3><ul><li>연산 결과가 주로 Operand1에 저장되므로 원래 Operand1에 있던 자료는 파괴된다.</li><li>전체 프로그램의 길이가 길어진다.</li></ul><h2 id="1주소-명령어"><a class="markdownIt-Anchor" href="#1주소-명령어"></a> 1주소 명령어</h2><ul><li>Operand가 한 개로 구성된 명령어 형식</li><li><strong>AC</strong>를 이용하여 명령어를 처리하므로 결과도 <strong>누산기</strong>에 저장된다.</li></ul><h2 id="0주소-명령어"><a class="markdownIt-Anchor" href="#0주소-명령어"></a> 0주소 명령어</h2><ul><li>Operand부 없이 OPCode만으로 구성</li><li>모든 연산은 Stack 메모리의 Stack Pointer가 가리키는 Operand를 이용하여 수행</li><li>스택 머신</li><li>인스트럭션 수행시간이 짧다.</li><li>기억공간 이용이 효율적</li><li>수식을 계산하기 위해선 Postfix 형태로 변경해야한다.</li><li>연산 결과를 다시 스택에 넣기 때문에 원래의 자료가 남지 않는다.</li></ul><h1 id="주소지정방식"><a class="markdownIt-Anchor" href="#주소지정방식"></a> 주소지정방식</h1><h2 id="고려사항"><a class="markdownIt-Anchor" href="#고려사항"></a> 고려사항</h2><ul><li>표현의 효율성 : 빠르게 접근가능하고, 주소지정에 적은 비트를 사용해야하며 다양항 Address 모드를 사용할 수 있어야한다.</li><li>사용의 편리성 : 프로그램 작업을 위해 포인터, 프로그램 리로케이션 등의 편의를 제공해야한다.</li><li>주소공간과 기억공간의 독립성 : 프로그램에서 사용한 주소를 변경 없이 실제 기억공간 내의 주소로 재배치할 수 있도록 서로 독립적이여야한다.<ul><li>주소공간 : 보조기억장치 내의 기억공간</li><li>기억공간 : 주기억장치 내의 기억공간</li></ul></li></ul><h2 id="암시적-주소지정방식"><a class="markdownIt-Anchor" href="#암시적-주소지정방식"></a> 암시적 주소지정방식</h2><ul><li>명령 실행에 필요한 데이터의 위치를 지정하지 않고 누산기나 스택의 데이터를 묵시적으로 지정하여 사용</li><li>오퍼랜드가 없는 명령이나 오퍼랜드가 1개인 명령어 형식에 사용</li></ul><h2 id="즉시적-주소지정방식"><a class="markdownIt-Anchor" href="#즉시적-주소지정방식"></a> 즉시적 주소지정방식</h2><ul><li>명령어 자체에 오퍼랜드를 가지고 있는 방식</li><li>별도의 기억장소를 액세스하지 않기 때문에 실행 속도가 빠르다.</li><li>데이터 값 범위가 제한적이다.</li></ul><h2 id="직접-주소지정방식"><a class="markdownIt-Anchor" href="#직접-주소지정방식"></a> 직접 주소지정방식</h2><ul><li>오퍼렌드부에 표현된 주소를 이용해 실제 데이터가 기억된 기억장소에 직접 매핑</li><li>실제 사용할 데이터의 유효주소를 적기 때문에 주소 길이에 제약을 받음</li><li>nBit 오퍼랜드부 =&gt; 2^n 개의 주소 표현 가능</li><li>오퍼렌드부에 데이터를 가지고 있는 레지스터의 번호를 지정하면 레지스터 모드</li></ul><h2 id="간접-주소지정방식"><a class="markdownIt-Anchor" href="#간접-주소지정방식"></a> 간접 주소지정방식</h2><ul><li>주기억장치를 두 번 이상 접근하여 데이터가 있는 기억장소에 도달</li><li>오퍼랜드부에 할당된 비트 수로 주소를 나타낼 수 없을 때 사용하는 방식</li><li>명령어의 길이가 짧고 제한되어도 긴 주소에 접근이 가능한 방식</li><li>레지스터 간접모드</li></ul><h2 id="계산에-의한-주소지정방식"><a class="markdownIt-Anchor" href="#계산에-의한-주소지정방식"></a> 계산에 의한 주소지정방식</h2><ul><li>오퍼랜드부와 CPU의 특정 레지스터 값이 더해져서 유효주소를 계산하는 방식</li><li>약식 주소</li><li>상대주소 : 명령어 주소 + PC</li><li>베이스 레지스터 : 명령어 주소 + Base Register<ul><li>명령어의 시작주소를 가지고 있는 레지스터</li><li>베이스 레지스터의 값과 명령어에 포함된 변위값을 더해 유효주소를 얻는 것을 재배치라고 한다.</li></ul></li><li>인덱스 레지스터 : 명령어 주소 + Index Register</li></ul><h1 id="마이크로-오퍼레이션"><a class="markdownIt-Anchor" href="#마이크로-오퍼레이션"></a> 마이크로 오퍼레이션</h1><ul><li>인스트럭션을 수행하기 위해 CPU 내의 레지스터와 플래그가 의미있는 상태변환을 하도록하는 동작</li><li>레지스터에 저장된 데이터에 의해 이루어진다.</li><li>한 개의 클록펄스 동안 실행되는 기본 동작</li><li>모든 마이크로 오퍼레이션은 CPU의 클록펄스에 맞춰 실행된다.</li><li>순서를 결정하기 위해 제어장치가 발생하는 신호를 제어신호</li><li>제어워드 : 레지스어틔 선택과 산술논리연산장치의 역할을 결정하고 어떤 마이크로 연산을 할 지 결정하는 비트의 모임 = 마이크로 명령어</li><li>마이크로 프로그램 : 제어워드가 저장되 있을 때 마이크로 프로그램</li></ul><h2 id="마이크로-사이클-타임"><a class="markdownIt-Anchor" href="#마이크로-사이클-타임"></a> 마이크로 사이클 타임</h2><ul><li>한 개의 마이크로 오퍼레이션을 수행하는데 걸리는 시간</li><li>CPU는 클록펄스에 의해 동기화되어 동작하는데 펄스를 CPU 클록이라하며 한 개의 마이크로 오퍼레이션은 CPU 클록 발생 주기의 간격 내에 실행된다.</li><li>CPU Cycle Time = CPU Clock Time</li><li>CPU 속도를 나타내는 척도</li><li>1us = 10^-6s, 1ns = 10^-9s</li></ul><h3 id="동기-고정식"><a class="markdownIt-Anchor" href="#동기-고정식"></a> 동기 고정식</h3><ul><li>모든 마이크로 오퍼레이션 동작시간이 같다고 가정해 클록 주기를 마이크로 사이클 타임과 같도록 정의하는 방식</li><li>동작 시간이 가장 긴 마이크로 오퍼레이션의 동작시간을 마이크로 사이클 타임으로 정한다.</li><li>모든 마이크로 오퍼레이션 동작시간이 비슷할 때 유리하다.</li><li>CPU 낭비가 심하다.</li><li>구현이 쉽다.</li></ul><h3 id="동기-가변식"><a class="markdownIt-Anchor" href="#동기-가변식"></a> 동기 가변식</h3><ul><li>수행시간이 유사한 마이크로 오퍼레이션끼리 그룹을 만들어 그룹별로 서로 다른 마이크로 사이클 타임을 정의하는 방식</li><li>수행시간이 현저한 차이를 나타낼 때 사용</li><li>CPU 시간 낭비를 줄일 수 있다.</li><li>구현이 복잡하다.</li><li>각 그룹(집합) 간 서로 다른 사이클 타임의 동기를 맞추기 위해 그룹간 마이크로 사이클 타임을 정수배가 되게 한다.</li></ul><h3 id="비동기식"><a class="markdownIt-Anchor" href="#비동기식"></a> 비동기식</h3><ul><li>모든 마이크로 오퍼레이션이 서로 다른 마이크로 사이클 타임을 가진다.</li><li>시간 낭비는 없다.</li><li>구현이 매우 복잡하다.</li><li>실제로 거의 사용되지 않는다.</li></ul><h1 id="메이저-스테이트"><a class="markdownIt-Anchor" href="#메이저-스테이트"></a> 메이저 스테이트</h1><ul><li>현재 CPU가 무엇을 하고 있는가를 나타내는 상태</li><li>Fetch, Indirect, Execute, Interrupt</li><li>Major Cycle = Machine Cycle</li><li>메이저 스테이트 레지스터를 통해 알 수 있다.</li><li>F와 R 플립플롭의 상태에 따라 메이저 스테이트 상태가 결정된다.</li></ul><h2 id="fetch-cycle"><a class="markdownIt-Anchor" href="#fetch-cycle"></a> Fetch Cycle</h2><ul><li>인출단계</li><li>중앙처리장치의 명령 레지스터로 명령어를 가져와 해독하는 단계</li><li>가장 먼저 수행되는 동작</li><li>1Cycle 명령어면 수행 후 다시 Fetch Cycle로 변경됨</li><li>1Cycle 명령어가 아니면 모드 비트에 따라 직 간접 주소를 판단</li><li>모드가 0이면 직접주소 =&gt; Execute 단계로</li><li>모드가 1이면 간접주소 =&gt; Indirect 단계로</li></ul><table><thead><tr><th style="text-align:center">Click Pulse</th><th style="text-align:center">Micro Operation</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">C0t0</td><td style="text-align:center">MAR ← PC</td><td style="text-align:center">PC의 번지를 MAR으로 전송</td></tr><tr><td style="text-align:center">C0t1</td><td style="text-align:center">MBR ← M[MAR]<br>PC ← PC +1</td><td style="text-align:center">MAR의 지정하는 위치의 <strong>값을 MBR에 전송</strong> 후<br>다음 시행할 명령 위치를 지정</td></tr><tr><td style="text-align:center">C0t2</td><td style="text-align:center">IR ← MBR[OP]<br>I ← MBR[I]</td><td style="text-align:center">명령어의 OPCode를 명령 레지스터에 전송<br>명령어의 모드 비트를 플립플롭 I에 전송</td></tr><tr><td style="text-align:center">C0t3</td><td style="text-align:center">F ← 1 OR R ← 1</td><td style="text-align:center">I에 따라 F나 R에 1 전송</td></tr></tbody></table><blockquote><ul><li>PC : 다음 실행할 명령의 주소가 들어있음</li><li>MAR : 저장하거나 읽어올 주기억장치의 주소가 들어있음</li><li>MBR : 주기억장치에서 읽어오거나 저장할 데이터가 들어있음</li><li>M[MAR] : 메모리에서 MAR에 해당하는 실제 데이터</li><li>IR : 현재 실행하는 명령어가 들어있음</li><li>OP : 명령 코드 부분</li><li>I : 모드 비트</li><li>AD : 명령 주소 부분</li><li>F, R : 다음 상태를 지정하는 플립플롭</li></ul></blockquote><h2 id="indirect-cycle"><a class="markdownIt-Anchor" href="#indirect-cycle"></a> Indirect Cycle</h2><ul><li>Fetch 단계에서 해석한 주소를 읽어온 후 간접주소이면 유효주소를 계산하기 위해 다시 Indirect 단계를 수행</li><li>직접주소인 경우 Execute 단계 또는 Fetch 단계로 이동<ul><li>분기같은 1Cycle 명령이면 Fetch로</li><li>실행이면 Execute로</li></ul></li></ul><table><thead><tr><th style="text-align:center">Click Pulse</th><th style="text-align:center">Micro Operation</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">C1t0</td><td style="text-align:center">MAR ← MBR[AD]</td><td style="text-align:center">MBR에 있는 명령어의 주소를 MAR에 전송</td></tr><tr><td style="text-align:center">C1t1</td><td style="text-align:center">MBR ← M[MAR]</td><td style="text-align:center">MAR이 지정하는 메모리의 실제 데이터를 MBR에 전송</td></tr><tr><td style="text-align:center">C1t2</td><td style="text-align:center">-</td><td style="text-align:center">동작없음</td></tr><tr><td style="text-align:center">C1t3</td><td style="text-align:center">F ← 1, R ← 0</td><td style="text-align:center">Execute 단계로 이동</td></tr></tbody></table><h2 id="execute-cycle"><a class="markdownIt-Anchor" href="#execute-cycle"></a> Execute Cycle</h2><ul><li>해석된 명령을 실행하는 단계</li><li>플래그 레지스터의 상태를 검사하여 Interrupt 단계로 갈지 결정</li></ul><table><thead><tr><th style="text-align:center">Click Pulse</th><th style="text-align:center">Micro Operation</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">C2t0</td><td style="text-align:center">MAR ← MBR[AD]</td><td style="text-align:center">MBR에 있는 명령어의 주소를 MAR에 전송</td></tr><tr><td style="text-align:center">C2t1</td><td style="text-align:center">MBR ← M[MAR]</td><td style="text-align:center">MAR이 지정하는 메모리의 실제 데이터를 MBR에 전송</td></tr><tr><td style="text-align:center">C2t2</td><td style="text-align:center">AC ← AC + MBR</td><td style="text-align:center">누산기에 값과 MBR의 값을 더해 ADD 연산 실행</td></tr><tr><td style="text-align:center">C2t3</td><td style="text-align:center">F ← 0 OR R ← 1</td><td style="text-align:center">F = 0이면 Fetch로, R = 1이면 Interrupt로</td></tr></tbody></table><h2 id="interrupt-cycle"><a class="markdownIt-Anchor" href="#interrupt-cycle"></a> Interrupt Cycle</h2><ul><li>인터럽트 발생시 복귀주소를 저장시키고 인터럽트 처리 프로그램의 첫 번째 명령으로 제어순서를 옮긴다.</li><li>인터럽트 단계는 항상 Fetch 단계로 이동된다.</li><li>메모리의 인터럽트 주소는 0번지에 저장되고, 인터럽트 벡터는 인터럽트 처리 프로그램의 주소 번지를 말한다.</li><li>현재 상태를 저장하고 인터럽트가 처리된다.</li><li>인터럽트 처리시 다음 실행주소를 PC에 넣고 인터럽트 벡터로 이동한다.</li></ul><table><thead><tr><th style="text-align:center">Click Pulse</th><th style="text-align:center">Micro Operation</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">C3t0</td><td style="text-align:center">MBR[AD] ← PC<br>PC ← 0</td><td style="text-align:center">다음 실행 명령 주소를 MBR의 주소로 전송<br>복귀주소를 저장할 0번지를 PC에 전송</td></tr><tr><td style="text-align:center">C3t1</td><td style="text-align:center">MAR ← PC<br>PC ← PC + 1</td><td style="text-align:center">PC가 가진 0값 번지를 MAR에 전송<br>인터럽트 벡터 위치를 지정하기 위해 PC 값을 1로 세팅</td></tr><tr><td style="text-align:center">C3t2</td><td style="text-align:center">M[MAR] ← MBR<br>IEN ← 0</td><td style="text-align:center">MBR에 있는 다음 실행 명령 주소를 0번지에 저장<br>다른 인터럽트가 발생하지 않게 IEN에 0 전송</td></tr><tr><td style="text-align:center">C3t3</td><td style="text-align:center">F ← 0, R ← 0</td><td style="text-align:center">항상 Fetch로</td></tr></tbody></table><h1 id="주요-마이크로-오퍼레이션"><a class="markdownIt-Anchor" href="#주요-마이크로-오퍼레이션"></a> 주요 마이크로 오퍼레이션</h1><h2 id="and-2"><a class="markdownIt-Anchor" href="#and-2"></a> AND</h2><ul><li>AC와 메모리의 내용을 AND 연산해서 AC에 저장</li><li>논리곱 연산</li><li>AC ← AC ∧ MBR</li></ul><h2 id="add"><a class="markdownIt-Anchor" href="#add"></a> ADD</h2><ul><li>AC와 메모리의 내용을 더해서 AC에 저장</li><li>AC ← AC +MBR</li></ul><h2 id="lda"><a class="markdownIt-Anchor" href="#lda"></a> LDA</h2><ul><li>메모리의 내용을 AC로 Load하는 명령</li><li>AC에 0을 전송하여 AC를 초기화하는 부분이 있어야함</li><li><strong>AC ← 0</strong></li><li>AC ← AC + MBR</li></ul><h2 id="sta"><a class="markdownIt-Anchor" href="#sta"></a> STA</h2><ul><li>AC의 내용을 메모리에 저장</li><li>M[MAR] ← MBR</li></ul><h2 id="bun"><a class="markdownIt-Anchor" href="#bun"></a> BUN</h2><ul><li>실행 명령의 위치를 변경하는 무조건 분기</li><li>Branch UNconditionally</li><li>PC ← MBR[AD]</li></ul><h2 id="bsa"><a class="markdownIt-Anchor" href="#bsa"></a> BSA</h2><ul><li>복귀주소를 저장하고 부 프로그램을 호출하는 명령</li><li>Branch and Save Return Address</li></ul><table><thead><tr><th style="text-align:center">Click Pulse</th><th style="text-align:center">Micro Operation</th><th style="text-align:center">Description</th></tr></thead><tbody><tr><td style="text-align:center">C2t0</td><td style="text-align:center">MAR ← MBR[AD]<br>MBR[AD] ← PC<br>PC ← MBR[AD]</td><td style="text-align:center">복귀주소를 MAR에 전송<br>PC의 값을 MBR의 주소로 전송<br>부프로그램 호출직전 MBR의 주소를 PC로 전송</td></tr><tr><td style="text-align:center">C2t1</td><td style="text-align:center">M[MAR] ← MBR[AD]</td><td style="text-align:center">부프로그램 호출직전 복귀주소 저장</td></tr><tr><td style="text-align:center">C2t2</td><td style="text-align:center">PC ← PC + 1</td><td style="text-align:center">부 프로그램 시작</td></tr><tr><td style="text-align:center">C2t3</td><td style="text-align:center">F ← 0 OR R ← 1</td><td style="text-align:center">Fetch 또는 Interrupt</td></tr></tbody></table><h2 id="isz"><a class="markdownIt-Anchor" href="#isz"></a> ISZ</h2><ul><li>메모리의 값을 읽고 값을 1 증가 시킨 후 그 값이 0이면 현재 명령을 건너 뛰고 다음으로 이동</li><li>IF(MBR=0) THEN ← PC + 1</li></ul><h1 id="제어기"><a class="markdownIt-Anchor" href="#제어기"></a> 제어기</h1><h2 id="제어데이터"><a class="markdownIt-Anchor" href="#제어데이터"></a> 제어데이터</h2><ul><li>제어장치가 제어신호를 발생하기 위한 자료</li><li>CPU가 특정한 메이저 상태와 타이밍 상태에 있을 때 제어 자료에 따른 제어 규칙에 의해 발생한다.</li></ul><h3 id="종류-2"><a class="markdownIt-Anchor" href="#종류-2"></a> 종류</h3><ul><li>메이저 스테이트 사이의 변천을 제어하는 데이터</li><li>중앙처리장치의 제어점을 제어하는 데이터</li><li>인스트럭션의 수행 순서를 결정하는데 필요한 제어데이터</li></ul><h3 id="단계"><a class="markdownIt-Anchor" href="#단계"></a> 단계</h3><table><thead><tr><th style="text-align:center">구분</th><th style="text-align:center">State간 변이</th><th style="text-align:center">제어점 제어</th><th style="text-align:center">수행 순서제어</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Fetch</strong></td><td style="text-align:center">명령어의 주소지정방식</td><td style="text-align:center">명령어</td><td style="text-align:center">PC</td></tr><tr><td style="text-align:center"><strong>Indirect</strong></td><td style="text-align:center">주소지정방식</td><td style="text-align:center">유효주소</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center"><strong>Execute</strong></td><td style="text-align:center">인터럽트 요청</td><td style="text-align:center">명령어 연산자</td><td style="text-align:center">PC</td></tr><tr><td style="text-align:center"><strong>Interrupt</strong></td><td style="text-align:center">-</td><td style="text-align:center">Interrupt따라 다름</td><td style="text-align:center">Interrupt따라 다름</td></tr></tbody></table><h2 id="구현"><a class="markdownIt-Anchor" href="#구현"></a> 구현</h2><ul><li>하드웨어적 고정배선제어장치</li><li>소프트웨어적 마이크로 프로그래밍 기법</li></ul><h3 id="고정배선-제어장치"><a class="markdownIt-Anchor" href="#고정배선-제어장치"></a> 고정배선 제어장치</h3><ul><li>독립 제어점에 제어신호를 가해야 할 조건들을 제어 데이터와 제어기의 상태로 표현한 후 이를 만족하는 조합논리회로를 설계하여 해당 제어점에 연결하는 방식</li><li>하드웨어적 구성방법</li><li>속도 빠름</li><li>비싸다.</li><li>RISC구조를 기본으로 하는 컴퓨터에서 주로 사용</li><li>한 번 만들어진 명령어 세트를 변경할 수 없음</li><li>회로 구성이 복잡</li></ul><h3 id="마이크로-프로그래밍"><a class="markdownIt-Anchor" href="#마이크로-프로그래밍"></a> 마이크로 프로그래밍</h3><ul><li>내부 제어 신호를 지정하는 여러가지 마이크로 인스트럭션으로 작성하는 것</li><li>소프트웨어적 구성방법</li><li>펌웨어를 이용하는 방식</li><li>마이크로 프로그램된 제어장치를 사용하는 컴퓨터는 주 메모리 외에 마이크로 프로그램이 저장되는 제어메모리(ROM)이 필요하다.</li><li>명령어 세트를 쉽게 변경할 수 있다.</li><li>다양한 어드레스 모드를 갖음</li><li>속도 느림</li><li>유지보수 및 수정 용이</li><li>복잡한 명령 세트를 가진 시스템에 적합</li></ul><h2 id="제어-메모리-번지-결정"><a class="markdownIt-Anchor" href="#제어-메모리-번지-결정"></a> 제어 메모리 번지 결정</h2><ul><li>제어 주소 레지스터(CAR) : 값을 1 증가<ul><li>매핑의 결과값</li><li>주소 필드</li><li>서브루틴 레지스터 데이터</li></ul></li><li>명령 레지스터(IR) : 지정하는 번지로 무조건 분기, 주소 필드로부터 제어 메모리의 주소로 매핑</li><li>상태 레지스터(SR) : 조건에 따른 분기</li><li>서브루틴의 호출(call)과 복귀(return)</li></ul><h2 id="형식"><a class="markdownIt-Anchor" href="#형식"></a> 형식</h2><h3 id="수평-마이크로-명령"><a class="markdownIt-Anchor" href="#수평-마이크로-명령"></a> 수평 마이크로 명령</h3><ul><li>Horizontal Micro Instruction</li><li>한 비트가 한 개의 마이크로 동작을 관할하는 명령</li><li>마이크로 오퍼레이션 부가 nBit일 때 n개의 마이크로 동작 표현 가능</li><li>제어 비트를 디코딩 할 필요가 없다.</li><li>마이크로 명령 한 개로 여러 개의 하드웨어를 동시에 동작시킬 수 있다.</li><li>제어 워드의 길이가 길어진다.</li><li>비트가 충분히 활용되지 못함.</li><li>비용이 많이 든다.</li></ul><h3 id="수직-마이크로-명령"><a class="markdownIt-Anchor" href="#수직-마이크로-명령"></a> 수직 마이크로 명령</h3><ul><li>Vertical Micro Instruction</li><li>제어 메모리 외부에서 디코딩 회로를 필요로 하는 마이크로 명령</li><li>디코더의 출력을 제어신호로 사용</li><li>한 개의 마이크로 동작만 제어 가능</li></ul><h3 id="나노-명령"><a class="markdownIt-Anchor" href="#나노-명령"></a> 나노 명령</h3><ul><li>Nano Instruction</li><li>나노메모리(낮은 레벨의 메모리)에 저장된 마이크로 명령</li><li>수직 마이크로 명령을 수행하는 제어기에서 디코더를 ROM(나노메모리)로 바꿔 두 메모리 레벨로 구성</li><li>제어 메모리의 각 워드는 나노 메모리의 번지를 저장</li></ul><h2 id="제어장치-구현방식"><a class="markdownIt-Anchor" href="#제어장치-구현방식"></a> 제어장치 구현방식</h2><ul><li>상태 플리플롭 제어</li><li>PLA (Programmable Logic Array)</li><li>마이크로 프로그램 제어</li></ul><h1 id="입출력장치"><a class="markdownIt-Anchor" href="#입출력장치"></a> 입출력장치</h1><h2 id="입출력-제어장치"><a class="markdownIt-Anchor" href="#입출력-제어장치"></a> 입출력 제어장치</h2><ul><li>입출력장치와 컴퓨터 사이의 자료 전송을 제어하는 장치</li><li>데이터 버퍼 레지스터를 이용하여 두 장치간의 속도 차를 조절 = 데이터 버퍼링</li><li>제어 신호의 논리적, 물리적 변환 및 오류를 제어</li><li>DMA, 채널, 입출력 프로세서, 입출력 컴퓨터가 포함된다.</li></ul><h2 id="입출력-인터페이스"><a class="markdownIt-Anchor" href="#입출력-인터페이스"></a> 입출력 인터페이스</h2><ul><li>동작방식이나 데이터 형식이 다른 컴퓨터 내부의 장치끼리 2진 데이터를 원활하게 전송하기 위함</li><li>CPU와 주변장치의 전송속도, 동작방식, 워드형식의 차이 제어</li><li>동작방식이 다른 주변장치끼리의 차이 제어</li></ul><h2 id="입출력-버스"><a class="markdownIt-Anchor" href="#입출력-버스"></a> 입출력 버스</h2><ul><li>주기억장치와 입출력장치 사이의 데이터 전송을 위해 <strong>모든 주변장치의 인터페이스에 공통으로 연결된 버스</strong></li><li>구성<ul><li>데이터 버스</li><li>주소 버스</li><li>제어 버스</li></ul></li></ul><h2 id="기억장치와-입출력장치의-차이"><a class="markdownIt-Anchor" href="#기억장치와-입출력장치의-차이"></a> 기억장치와 입출력장치의 차이</h2><ul><li>기억장치 : 전자적, 빠르다, 타율, 오류 적음, Word단위</li><li>입출력장치 : 기계적, 느리다, 자타율, 오류 많음, Byte(문자)단위</li></ul><h2 id="비동기-데이터-전송"><a class="markdownIt-Anchor" href="#비동기-데이터-전송"></a> 비동기 데이터 전송</h2><ul><li>비동기 데이터 전송을 하기 위해선 데이터 전송시각을 알기 위한 제어신호를 서로 교환하여 송수신 상태를 서로 맞춰야한다.</li></ul><h3 id="스트로브-펄스"><a class="markdownIt-Anchor" href="#스트로브-펄스"></a> 스트로브 펄스</h3><ul><li>Strobe Pulse</li><li>데이터 버스와 한 개의 제어선</li><li>스트로브 신호 : 두 개의 독립적인 장치 사이의 비동기적인 데이터 전송을 하기 위해 전송 시각을 알리는 제어 신호</li><li>메모리와 CPU 사이의 정보를 교환할 때 사용</li><li>수신장치가 데이터를 받았는지는 모름</li></ul><h3 id="핸드쉐이킹"><a class="markdownIt-Anchor" href="#핸드쉐이킹"></a> 핸드쉐이킹</h3><ul><li>데이터 전송시 송신측과 수신측에서 입출력의 준비나 완료를 나타내는 신호를 사용하여 서로의 동작을 확인하면서 데이터를 전송</li><li>전송을 시작한 장치에 응답하는 제 2의 제어신호를 전송</li><li>높은 융통성과 신뢰성</li><li>병렬 입출력 데이터 전송방식의 기본으로 많이 사용</li><li>2~3개의 제어선 사용</li><li>RDY, STB 신호 사용</li></ul><h2 id="스풀링"><a class="markdownIt-Anchor" href="#스풀링"></a> 스풀링</h2><ul><li>다중 프로그래밍 환경 아래에서 용량이 크고 신속한 액세스가 가능한 디스크를 이용해 각 사용자 프로그램이 입출력할 데이터를 직접 입출력장치로 보내지 않고 디스크에 모았다가 한꺼번에 입출력 시키는 방법</li><li>입출력장치의 공유 및 느린 처리속도를 보완</li><li>디스크의 일부를 매우 큰 버퍼로 사용한다.</li><li>큐 방식의 입출력을 수행</li><li>Simultaneous Peripheral Operation OnLine</li><li>보조기억장치에 저장</li><li>다중 작업</li><li>소프트웨어 구현</li></ul><h2 id="버퍼링"><a class="markdownIt-Anchor" href="#버퍼링"></a> 버퍼링</h2><ul><li>입출력 장치와 CPU의 속도차를 해결하기 위해 사용</li><li>주기억 장치에 저장</li><li>단일 작업</li><li>하드웨어 구현</li></ul><h1 id="입출력-제어방식"><a class="markdownIt-Anchor" href="#입출력-제어방식"></a> 입출력 제어방식</h1><ul><li>입출력 처리 능력 순서 : 프로그램 &lt; 인터럽트 &lt; DMA &lt; 채널</li></ul><h2 id="programmed-io"><a class="markdownIt-Anchor" href="#programmed-io"></a> Programmed I/O</h2><ul><li>폴링</li><li>원하는 I/O가 완료되었는지 여부를 검사하기 위해 CPU의 Status Flag를 계속 조사해 I/O가 완료되었으면 MDR(MBR)과 AC사이의 자료 전송도 CPU가 직접 처리하는 방식</li><li>입출력의 대부분을 CPU가 해준다.</li><li>MDR(MBR), Flag(PSW), 장치번호 디코더로 구성</li><li>CPU가 계속 I/O에 관여해야되기 때문에 비효율적</li></ul><h2 id="interrupt-io"><a class="markdownIt-Anchor" href="#interrupt-io"></a> Interrupt I/O</h2><ul><li>데이터 전송 준비가 되면 입출력 인터페이스가 컴퓨터에게 알려 I/O가 이루어지는 방식</li><li>입출력 인터페이스가 CPU에게 인터럽트 신호를 전송</li><li>수행중인 프로그램의 <strong>인스트럭션을 끝내고</strong> I/O 처리후 다시 복귀</li><li>대량 자료 전송시 CPU에 부담</li></ul><h2 id="dma-io"><a class="markdownIt-Anchor" href="#dma-io"></a> DMA I/O</h2><ul><li>Direct Memory Access</li><li>입출력장치가 직접 주기억장치를 접근하여 데이터 블록을 입출력하는 방식</li><li>I/O가 CPU를 경유하지 않음</li><li>CPU는 I/O에 필요한 정보를 DMA 제어기에 전달해 I/O동작만을 개시하고 끝<ul><li>I/O 장치의 주소</li><li>데이터 있는 주기억장치의 시작 주소</li><li>DMA 시작 명령</li><li>I/O 데이터 양</li><li>입력 또는 출력을 결정하는 명령</li></ul></li><li>빠른 데이터 전송 가능</li><li>DMA는 인터럽트 신호를 발생해 CPU에게 I/O 종료를 알림</li><li>블록으로 대용량 데이터 전송 가능</li><li>CPU의 <strong>Cycle Steal</strong> 해 메모리를 접근하여 I/O 데이터를 전송<ul><li>데이터 채널과 CPU가 주기억장치를 동시에 접근할 때 우선순위를 전자에게 줌</li><li>CPU는 그동안 메모리 참조가 필요없는 오퍼레이션을 계속 진행</li><li>CPU의 상태 보존이 필요 없음</li></ul></li><li>CPU와 DMA 제어기는 메모리와 버스를 공유</li><li>명령 받고 =&gt; 버스 사용 요구 =&gt; 버스 사용 허가 =&gt; 데이터 전송 =&gt; 인터럽트 전송</li><li>한 개의 인스트럭션에 의해 한 개의 블록을 입출력</li></ul><h3 id="구성"><a class="markdownIt-Anchor" href="#구성"></a> 구성</h3><ul><li>인터페이스 회로</li><li>주소 레지스터 및 주소 라인</li><li>워드 카운트 레지스터 = 단어 계수기</li><li>제어 레지스터</li><li>데이터 레지스터</li></ul><h2 id="channel-io"><a class="markdownIt-Anchor" href="#channel-io"></a> Channel I/O</h2><ul><li>I/O 프로세서</li><li>I/O를 위한 특별한 명령어를 I/O 프로세서에게 수행토록 하여 CPU 관여 없이 주기억장치와 입출력장치 사이에서 I/O를 하는 전용 프로세서</li><li>DMA의 한계를 극복하기 위해 고안</li><li>DMA의 방법으로 입출력을 수행하지만 확장된 개념</li><li>채널 제어기는 채널 명령어로 작성된 채널 프로그램을 해독하고 실행하여 I/O 처리</li><li>CPU로 I/O 명령어를 받으면 CPU와는 독립적으로 동작</li><li>주기억장치에 저장된 채널 프로그램의 수행과 데이터 전송을 위해 주기억장치에 직접 접근</li><li>I/O 장치는 제어장치를 통해 채널과 연결</li><li>I/O 채널은 CPU의 I/O 명령을 수행하지 않고 I/O 채널 내의 특별한 명령어를 수행</li><li>CPU와는 인터럽트로 통신</li><li>한 개의 인스트럭션에 의해 여러 개의 블록을 입출력</li><li>입출력장치와 주기억장치를 연결하는 중개자</li><li>입출력 전담장치</li><li>입출력 장치와 CPU사이의 존재하는 현저한 속도차를 극복하기 위한 장치</li><li>CPU의 명령을 받고 입출력을 시작하면 CPU와는 독립적으로 조작하는 장치</li></ul><h3 id="채널-명령어"><a class="markdownIt-Anchor" href="#채널-명령어"></a> 채널 명령어</h3><ul><li>명령코드</li><li>데이터 주소</li><li>플래그</li><li>워드 카운터</li></ul><h3 id="종류-3"><a class="markdownIt-Anchor" href="#종류-3"></a> 종류</h3><ul><li>Selector Channel<ul><li>선택 채널</li><li>고속 입출력장치(자기로 시작하는 친구들)와 입출력하기 위해 사용</li><li>특정 한 개의 장치를 독점해서 입출력</li></ul></li><li>MultiPlexer Channel<ul><li>다중채널</li><li>저속 입출력장치(카드리터, 프린터)를 제어하는 채널</li><li>동시에 여러 개의 입출력장치 제어</li></ul></li><li>Block Multiplexer Channel<ul><li>고속 입출력장치를 제어</li><li>동시에 여러 개의 입출력장치 제어</li></ul></li></ul><h1 id="인터럽트"><a class="markdownIt-Anchor" href="#인터럽트"></a> 인터럽트</h1><ul><li>프로그램 실행 도중 예기치 않은 상황이 발생하는 경우 현재 작업을 즉시 중단하고 발생된 상황을 우선 처리 후 실행 중인 작업으로 복귀</li><li>내부 인터럽트는 CPU의 하드웨어 신호에 의해 발생</li><li>소프트웨어 인터럽트는 명령어의 수행에 의해 발생</li></ul><h2 id="외부-인터럽트"><a class="markdownIt-Anchor" href="#외부-인터럽트"></a> 외부 인터럽트</h2><ul><li>입출력장치, 타이밍장치, 전원 등 외부 요인에 의해 발생</li><li>전원 이상 인터럽트 : 정전이거나 정원이상</li><li>기게 착오 인터럽트 : CPU의 기능적인 오류 동작 발생</li><li>외부 신호 인터럽트<ul><li>Time Slice 를 알림</li><li>인터럽트 키를 누른 경우 (Ctrl + Alt + Del)</li><li>외부 장치로부터 인터럽트 요청이 있는 경우</li></ul></li><li>입출력 인터럽트<ul><li>입출력 데이터의 오류나 이상현상 발생</li><li>입출력장치가 데이터 전송을 요구하거나 전송이 끝났을 때</li></ul></li></ul><h2 id="내부-인터럽트"><a class="markdownIt-Anchor" href="#내부-인터럽트"></a> 내부 인터럽트</h2><ul><li>잘못된 명령이나 데이터를 사용할 때 발생</li><li><strong>트랩</strong></li><li>프로그램 검사 인터럽트<ul><li>0으로 나누기</li><li>오버플로 또는 언더플로</li><li>프로그램에서 명령어 잘못 사용</li><li>부당한 기억장소의 참조</li><li>프로그램상 오류</li></ul></li></ul><h2 id="소프트웨어-인터럽트"><a class="markdownIt-Anchor" href="#소프트웨어-인터럽트"></a> 소프트웨어 인터럽트</h2><ul><li>프로그램 처리중 <strong>명령의 요청에 의해 발생</strong></li><li><strong>SVC 인터럽트</strong><ul><li>제어 프로그램 호출 인터럽트 = SuperVisor Call</li><li>사용자가 SVC 명령을 써서 의도적으로 호출한 경우</li><li>복잡한 입출력 처리를 해야하는 경우</li><li>기억장치 할당 및 오퍼레이터와 대화를 해야하는 경우</li></ul></li></ul><h2 id="인터럽트시-cpu확인-요소"><a class="markdownIt-Anchor" href="#인터럽트시-cpu확인-요소"></a> 인터럽트시 CPU확인 요소</h2><ul><li>프로그램 카운터 내용</li><li>사용한 모든 레지스터의 내용</li><li>상태 조건의 내용 = PSW = Status Register</li></ul><h2 id="동작-원리"><a class="markdownIt-Anchor" href="#동작-원리"></a> 동작 원리</h2><ol><li>인터럽트 요청 신호 발생</li><li>현재 인스트럭션까지 실행 후 프로그램 실행 중단</li><li>현재 프로그램 상태 보존</li><li>인터럽트 처리 루틴 실행</li><li>인터럽트 서비스(취급) 루틴 실행</li></ol><ul><li>처리기 상태 복구</li><li>인터럽트 원인 결정</li><li>처리기 레지스터의 상태 보존</li><li>상대적으로 낮은 레벨의 마스크 레지스터 클리어</li></ul><ol start="6"><li>상태 복구</li><li>중단된 프로그램 실행 재개</li></ol><h1 id="인터럽트-우선순위"><a class="markdownIt-Anchor" href="#인터럽트-우선순위"></a> 인터럽트 우선순위</h1><ol><li>전원 이상 = Power Fail</li><li>기계 착오 = Machine Check</li><li>외부 신호 = External</li><li>입출력 = I/O</li><li>명령어 잘못</li><li>프로그램 = Program Check</li><li>SVC = Supervisor Call</li></ol><ul><li>Non Maskable Interrupt : 마스크 불가능 인터럽트로 0순위</li></ul><h2 id="폴링"><a class="markdownIt-Anchor" href="#폴링"></a> 폴링</h2><ul><li>소프트웨어적 인터럽트 우선순위 판별 방식</li><li>우선순위가 높은 인터럽트 자원의 인터럽트 요청 플래그를 검사해 해당하는 인터럽트 서비스 루틴을 수행</li><li>우선순위 변경이 쉽다.</li><li>자기디스크와 같이 속도가 빠른 장치에 높은 등급 부여</li><li>회로가 간단하고 융통성이 있음</li><li>별도의 하드웨어가 필요 없어 경제적</li><li>많은 인터럽트가 있을 때 모두 조사해야하므로 반응시간이 느림</li></ul><h2 id="벡터-인터럽트"><a class="markdownIt-Anchor" href="#벡터-인터럽트"></a> 벡터 인터럽트</h2><ul><li>하드웨어적인 인터럽트 판별 방식</li><li>CPU와 인터럽트를 요청할 수 있는 장치 사이에 장치 번호에 해당하는 버스를 연결하여 요청 장치의 번호를 CPU에게 알리는 방식</li><li>인터럽트를 발생한 장치가 프로세서에게 분기할 곳에 대한 정보를 제공</li><li>인터럽트 벡터 : 인터럽트 처리 루틴으로 분기하는 명령어만을 기억하는 기억장치의 특정 영역으로 분기번지가 저장됨</li><li>별도의 프로그램 루틴이 없어 응답속도가 빠름</li><li>회로가 복잡하고 융통성이 없음</li><li>추가 하드웨어가 필요하므로 비경제적</li></ul><h3 id="직렬-우선순위"><a class="markdownIt-Anchor" href="#직렬-우선순위"></a> 직렬 우선순위</h3><ul><li><strong>데이지 체인 방식</strong></li><li>모든 장치를 한 개의 회선에 <strong>직렬</strong>로 연결</li></ul><h3 id="병렬-우선순위"><a class="markdownIt-Anchor" href="#병렬-우선순위"></a> 병렬 우선순위</h3><ul><li>인터럽트가 발생하는 각 장치를 개별적인 회선으로 연결</li><li>각 비트를 개별적으로 세트할 수 있는 <strong>Mask Register</strong> 사용</li><li>마스크 레지스터는 인터럽트 요청의 허락이 가능하다.</li><li>우선순위는 마스크 레지스터의 비트 위치에 의해서 결정</li><li>우선순위가 높은 것이 서비스 받고 있을 때 우선순위가 낮은 것을 비활성화시킬 수 있다.</li><li>높은 우선순위의 인터럽트는 낮은 인터럽트가 처리되는 중에도 우선 처리된다.</li></ul><h1 id="기억장치"><a class="markdownIt-Anchor" href="#기억장치"></a> 기억장치</h1><ul><li><p>주기억장치 : 시스템 프로그램영역과 사용자 프로그램영역으로 구성</p><ul><li>반도체 : RAM, ROM</li><li>자기 : 자기 코어</li></ul></li><li><p>보조기억장치</p><ul><li>DASD : 자기 디스크, 자기 드럼, 하드 디스크, 광디스크</li><li>SASD : 자기테이프</li></ul></li><li><p>특수기억장치 : 복수 모듈 기억장치, 연관기억장치, 캐시기억장치, 가상기억장치</p></li><li><p>광디스크의 종류 : 블루레이, DVD, Compact</p></li></ul><h2 id="계층구조"><a class="markdownIt-Anchor" href="#계층구조"></a> 계층구조</h2><ul><li>특수기억장치 : 레지스터, 캐시, 연관</li><li>주기억장치 : RAM, ROM, 자기코어</li><li>보조기억장치 : 자기디스크, 자기테이프</li></ul><h2 id="특성-결정-요소"><a class="markdownIt-Anchor" href="#특성-결정-요소"></a> 특성 결정 요소</h2><h3 id="기억-용량"><a class="markdownIt-Anchor" href="#기억-용량"></a> 기억 용량</h3><h3 id="access-time"><a class="markdownIt-Anchor" href="#access-time"></a> Access Time</h3><ul><li>기억장치에 읽기 요청이 발생한 시간부터 요구한 정보를 꺼내서 사용 가능할 때까지의 시간</li><li>한 Word의 단위 정보를 읽거나 기록하는데 걸리는 시간</li><li>Access Time = Seek Time + Latency Time(Search Time) + Transmission Time</li></ul><h3 id="cycle-time"><a class="markdownIt-Anchor" href="#cycle-time"></a> Cycle Time</h3><ul><li>기억장치에 읽기 신호를 보낸 후 다시 읽기 신호를 보낼 수 있을 때까지의 시간 간격</li><li>Cycle Time ≥ Access Time</li><li>DRAM : Cycle Time = Access Time + Refresh Time</li><li>자기코어 : Cycle Time = Access Time + Restoration Time</li><li><strong>기타 모든 장치</strong> : Cycle Time = Access Time</li></ul><h3 id="bandwitdh"><a class="markdownIt-Anchor" href="#bandwitdh"></a> Bandwitdh</h3><ul><li>대역폭 = 전송률 = 밴드폭</li><li>메모리에서 또는 메모리까지 1초동안 전송되는 최대한의 정보량</li><li>기억장치의 자료 처리 속도를 나타내는 단위</li><li>하드웨어 특성상 주기억장치가 제공할 수 있는 정보 전달능력의 한계를 의미</li><li>메모리 워드의 길이가 작을수록 대역폭이 좋음</li><li>전송단위 : bps = Baud = 보</li></ul><h2 id="구분"><a class="markdownIt-Anchor" href="#구분"></a> 구분</h2><table><thead><tr><th style="text-align:center">구분방식</th><th>내용</th></tr></thead><tbody><tr><td style="text-align:center">내용보존여부</td><td>_ 파괴성 메모리 : 읽으면 내용이 파괴되므로 재저장시간이 필요<br>_ 비파괴성 메모리</td></tr><tr><td style="text-align:center">전원차단시<br>내용소멸여부</td><td>_ 휘발성메모리 : RAM<br>_ 비휘발성 메모리 : ROM, 자기코어, 보조기억장치</td></tr><tr><td style="text-align:center">재충전 여부</td><td>_ 정적메모리(SRAM) : 전원이 공급되면 내용이 계속 유지<br>_ 전원이 공급되도 일정시간 후 내용 지워져 재충전필요</td></tr><tr><td style="text-align:center">접근 방식</td><td>_ 순차접근 : 자기테이프<br>_ 직접접근 : 자기테이프 제외 모든장치</td></tr></tbody></table><h1 id="주기억장치"><a class="markdownIt-Anchor" href="#주기억장치"></a> 주기억장치</h1><h2 id="rom"><a class="markdownIt-Anchor" href="#rom"></a> ROM</h2><ul><li>Read Only Memory</li><li>읽기전용</li><li>비휘발성 메모리</li><li>BIOS, 자가진단프로그램 등 변경 가능성이 거의 없는 시스템 소프트웨어 탑재</li></ul><h3 id="종류-4"><a class="markdownIt-Anchor" href="#종류-4"></a> 종류</h3><ul><li>Mask ROM : 제조 공장에서 프로그램되어 나옴, 내용 변경 불가</li><li>PROM : Programmable ROM, 한 번만 쓰기 가능</li><li>EPROM : Erasable PROM, 자외선을 사용해 내용을 지울 수 있음</li><li>EAROM : Erasable Alterable ROM, 전기적 특성을 이용하여 기록된 정보 일부를 바꿀 수 있는 ROM</li><li>EEPROM : Electonic EPROM, 전기를 이용해 내용 수정 가능</li></ul><h2 id="ram"><a class="markdownIt-Anchor" href="#ram"></a> RAM</h2><ul><li>Random Access Memory, Read Write Memory</li><li>현재 사용중인 프로그램이나 데이터가 저장</li><li>휘발성 메모리 = Volatile Memory</li><li>정보가 저장된 위치는 주소로 구분</li></ul><table><thead><tr><th style="text-align:center">구분</th><th style="text-align:center">동적 램</th><th style="text-align:center">정적 램</th></tr></thead><tbody><tr><td style="text-align:center">구성</td><td style="text-align:center">콘덴서</td><td style="text-align:center">플리플롭</td></tr><tr><td style="text-align:center">특징</td><td style="text-align:center">방전되므로주기적인 재충전</td><td style="text-align:center">전원 공급시에 계속 유지</td></tr><tr><td style="text-align:center">소모전력</td><td style="text-align:center">적음</td><td style="text-align:center">많음</td></tr><tr><td style="text-align:center">속도</td><td style="text-align:center">느림</td><td style="text-align:center">빠름</td></tr><tr><td style="text-align:center">집적도</td><td style="text-align:center">높음</td><td style="text-align:center">낮음</td></tr><tr><td style="text-align:center">가격</td><td style="text-align:center">저가</td><td style="text-align:center">고가</td></tr><tr><td style="text-align:center">용도</td><td style="text-align:center">일반적</td><td style="text-align:center">캐시메모리</td></tr></tbody></table><h2 id="자기-코어"><a class="markdownIt-Anchor" href="#자기-코어"></a> 자기 코어</h2><ul><li>전류 일치 기술에 의하여 기억장소를 선별</li><li>데이터를 읽으면 내용이 지워지는 <strong>파괴 메모리</strong></li><li>Dectructive Read Out Memory</li><li>내용을 읽은 후 지워진 내용을 기록하기 위한 재저장 시간 필요</li><li>현재 거의 사용되지 않음</li></ul><h3 id="구성-2"><a class="markdownIt-Anchor" href="#구성-2"></a> 구성</h3><ul><li>구동선 : X,Y축 번지 선택선 2개</li><li>센스선 : 자기 코어의 상태를 검출하는 선 1개</li><li>금지선 : 불필요하게 자화되었을 때 금지 전류를 흘려 자화를 소진시키는 선 1개</li></ul><h2 id="반도체-기억소자-구성"><a class="markdownIt-Anchor" href="#반도체-기억소자-구성"></a> 반도체 기억소자 구성</h2><h3 id="ram-2"><a class="markdownIt-Anchor" href="#ram-2"></a> RAM</h3><ul><li>CS1, CS2 : 칩 선택선</li><li>RD : 입력 신호선</li><li>WR : 출력 신호선</li><li><strong>AD</strong> : 주소선<ul><li>MAR과 PC의 수와 같음</li><li>주소선이 n개이면 2^n개의 워드 지정 가능</li></ul></li><li>Data Bus : 워드의 크기<ul><li>MBR = IR = 단어의 크기</li><li>버스가 10Bit이면 워드의 크기가 10Bit</li></ul></li></ul><h3 id="rom-2"><a class="markdownIt-Anchor" href="#rom-2"></a> ROM</h3><ul><li>CS1, CS2 : 칩 선택선</li><li><strong>AD</strong> : 주소선</li><li>Data Bus : 워드의 크기</li></ul><h1 id="보조기억장치"><a class="markdownIt-Anchor" href="#보조기억장치"></a> 보조기억장치</h1><ul><li>주기억 장치의 단점 보완</li><li>속도는 느리지만 전원이 차단되도 내용 유지</li><li>저장용량이 큼</li><li>CPU와 직접 자료교환이 불가능</li><li>주기억장치에 데이터를 저장할 때 DMA를 사용</li></ul><h2 id="자기-테이프"><a class="markdownIt-Anchor" href="#자기-테이프"></a> 자기 테이프</h2><ul><li>순차처리 = SASD</li><li>블록단위로 데이터를 전송</li><li>블록 사이에는 데이터를 기록할 수 없는 공간인 <strong>갭</strong>이 있다.</li><li>BOT : Beginning Of Tape</li><li>EOT : End Of Tape</li><li>BPI : Byte Per Inch, 1인치에 기억할 수 있는 바이트 수</li><li>IRG : Inter Record Gap, 레코드와 레코드 사이의 갭</li><li>IBG : Inter Block Gap, 블록과 블록 사이의 갭</li><li>Block : 한 개 이상의 논리 레코드의 집합 = 물리 레코드</li><li>블로킹 : 한 개 이상의 논리적 레코드를 묶어서 테이프에 기록하는 방식<ul><li>IRG가 줄어든다.</li><li>기억공간 낭비 감소</li><li>Access Time 감소</li><li>입출력 횟수 감소</li></ul></li><li>Blocking Factor : 하나의 블록을 구성하는 논리 레코드의 갯수</li></ul><h2 id="자기-디스크"><a class="markdownIt-Anchor" href="#자기-디스크"></a> 자기 디스크</h2><ul><li>DASD</li><li>회전축에 여러장의 디스크를 연결하고, 디스크 상하면마다 R/W Head를 액세스암에 연결하여 구성</li><li>가장 윗면과 가장 아랫면은 사용하지 않는다.</li><li>트랙 : 디스크 표면에서 회전푹을 중심으로 데이터가 기록되는 동심원</li><li>섹터 : 트랙들을 일정한 크기로 구분한 부분이며 정보 기록의 기본 단위</li><li>실린더 : 서로 다른 면들에 있는 동일 위치의 트랙들의 모임</li><li>Random Access와 Sequential Access 방식을 모두 사용</li></ul><h3 id="디스크의-3요소"><a class="markdownIt-Anchor" href="#디스크의-3요소"></a> 디스크의 3요소</h3><ul><li>디스크</li><li>액세스암</li><li>헤드</li></ul><h3 id="access-time-2"><a class="markdownIt-Anchor" href="#access-time-2"></a> Access Time</h3><ul><li>Access Time = Seek Time + Latency Time + Transmission Time</li><li>Seek Time : 탐색시간으로 R/W Head가 특정 트랙까지 이동하는데 걸리는 시간</li><li>Latency Time : R/W Head가 특정 트랙까지 이동한 후 디스크가 회전하여 트랙에 포함되어 있는 특정 섹터가 R/W Head까지 도달하는데 걸리는 시간<ul><li>Search Time = Rotational Delay Time</li></ul></li><li>Transmission Time : 전송시간으로 R/W Head가 액세스한 섹터와 주기억장치 간의 자료전송에 걸리는 시간</li></ul><h2 id="자기-드럼"><a class="markdownIt-Anchor" href="#자기-드럼"></a> 자기 드럼</h2><ul><li>각 트랙마다 고정된 R/W Head를 두고 있다.</li><li>DASD</li><li>Access Time = Latency Time + Transmission Time</li></ul><h1 id="연관기억장치"><a class="markdownIt-Anchor" href="#연관기억장치"></a> 연관기억장치</h1><ul><li>기억장치에서 기억된 내용의 일부를 이용하여 액세스하는 자료를 찾는 기억장치</li><li>CAM = Content Addressable Memory = 연상기억장치</li><li>정보 검색 빠름</li><li>캐시 메모리나 가상 메모리 관리기법에서 사용하는 <strong>매핑 테이블에 사용</strong></li><li>외부 인자와 내용을 비교하기 위한 병렬 판독 논리회로를 가지고 있음</li><li>하드웨어 비용 증가</li></ul><h2 id="구조"><a class="markdownIt-Anchor" href="#구조"></a> 구조</h2><ul><li>데이터 레지스터 : 인수 레지스터, 찾고자 하는 내용의 일부를 기억하는 레지스터</li><li>키 레지스터 : 마스크 레지스터, 검색에 사용할 비트를 결정하는 레지스터</li><li>매치 레지스터 : 일치 지시기, 데이터를 찾은 경우 찾았다고 표시하기 위해 사용</li></ul><h1 id="복수모듈기억장치"><a class="markdownIt-Anchor" href="#복수모듈기억장치"></a> 복수모듈기억장치</h1><ul><li>독자적으로 데이터를 저장할 수 있는 기억장치 모듈을 여러 개 가진 기억장치</li><li>주기억장치와 CPU의 속도 차이 문제점을 개선</li><li>기억장치의 버스를 시분할하여 사용</li><li>각각의 기억장치는 자체 어드레스 레지스터와 버퍼 레지스터를 가지고 독자적으로 데이터를 저장</li><li>인터리빙 기법에 의해 기억장치를 구성하는 모듈 수만큼 단어(워드)들에 동시 접근 가능</li><li>버스가 많으면 모든 모듈 동시 병렬 접근 가능</li></ul><h2 id="메모리-인터리빙"><a class="markdownIt-Anchor" href="#메모리-인터리빙"></a> 메모리 인터리빙</h2><ul><li>Memory Interleaving = 디스크 인터리빙</li><li>여러 개의 독립 모듈로 이루어진 복수 모듈 메모리와 CPU 간의 주소 버스가 한 개로만 구성되어 있으면 같은 시각에 CPU로부터 여러 모듈로 동시에 주소를 전달할 수 없다.</li><li>CPU가 각 모듈로 전송할 주소를 교대로 배치한 후 차례대로 전송하여 여러 모듈을 병행 접근하는 기법</li><li>중앙처리장치와 기억장치 사이의 실질적인 대역폭 효율을 높일 수 있다.</li><li>캐시 기억장치, 고속 DMA에서 사용</li><li>CPU 유휴시간 감소</li></ul><h1 id="캐시-메모리"><a class="markdownIt-Anchor" href="#캐시-메모리"></a> 캐시 메모리</h1><ul><li>CPU와 주기억장치의 속도차를 줄이기 위해 사용</li><li>고속 Buffer Memory</li><li>자주 사용하는 프로그램과 데이터를 기억</li><li>메모리 계층에서 가장 빠른 소자</li><li>캐시 주소표는 검색 시간을 단축시키기 위해 연관기억장치(CAM)을 사용</li></ul><h2 id="설계-고려사항"><a class="markdownIt-Anchor" href="#설계-고려사항"></a> 설계 고려사항</h2><ul><li>캐시 크기</li><li>전송 블록 크기</li><li>교체 알고리즘</li></ul><h2 id="매핑-프로세스"><a class="markdownIt-Anchor" href="#매핑-프로세스"></a> 매핑 프로세스</h2><p>주기억장치로부터 캐시 메모리로 데이터를 전송하는 방법</p><h3 id="직접-매핑"><a class="markdownIt-Anchor" href="#직접-매핑"></a> 직접 매핑</h3><ul><li>Direct Mapping</li><li>주기억장치의 블록들이 지정된 한 개의 캐시 라인으로만 매핑되는 방법</li><li>간단하고 구현 비용이 적다</li><li>적중률이 낮다</li></ul><h3 id="어소시에이티브-매핑"><a class="markdownIt-Anchor" href="#어소시에이티브-매핑"></a> 어소시에이티브 매핑</h3><ul><li>Assciative Mapping = 연관 매핑</li><li>직접 매핑의 단점 보완</li><li>모든 태그를 병렬로 검사하기 때문에 복잡하고 비용이 높음</li><li>거의 사용안함</li></ul><h3 id="세트-어소시에이티브-매핑"><a class="markdownIt-Anchor" href="#세트-어소시에이티브-매핑"></a> 세트-어소시에이티브 매핑</h3><ul><li>직접 매핑과 연관 매핑의 장점만 취함</li></ul><h2 id="쓰기-정책"><a class="markdownIt-Anchor" href="#쓰기-정책"></a> 쓰기 정책</h2><p>저장되어 있는 데이터 수정이 발생할 때 수정된 내용을 주기억장치에 갱신하기 위해 시기와 방법을 결정하는 것</p><ul><li>Wirte-Through : 캐시에 쓰기 동작이 이루어질 때마다 캐시 메모리와 주기억장치의 내용을 동시 갱신</li><li>Write-Back : 캐시에 쓰기 동작이 이루어지는 동안은 캐시의 내용만이 갱신, 캐시의 내용이 캐시로부터 제거될 때 주기억장치에 복사</li><li>Write-Once : 캐시에 쓰기 동작이 이루어질 때 한 번만 기록하고 이후의 기록은 모두 무시</li></ul><h2 id="적중률"><a class="markdownIt-Anchor" href="#적중률"></a> 적중률</h2><ul><li>캐시메모리에 접근하는 경우 원하는 정보가 캐시 메모리에 기억되어 있을 때 적중되었다고 함</li><li>캐시 기억장치가 있는 컴퓨터의 성능을 나타네내는 척도</li><li>적중률 = 적중횟수 / 총 접근 횟수</li><li>미스율 = 1 - 적중률</li></ul><h1 id="가상기억장치"><a class="markdownIt-Anchor" href="#가상기억장치"></a> 가상기억장치</h1><ul><li><strong>기억 용량이 작은 주기억장치를 큰 용량을 가진 것</strong>처럼 사용할 수 있는 기법</li><li>보조기억장치를 이용한 주기억장치의 용량 확보</li><li>소프트웨어적 방법으로 구현</li><li>프로그램을 여러 블록으로 나눠서 보조기억장치에 보관하고 프로그램 실행시 필요 부분만 주기억장치에 적재</li><li><strong>오버레이 문제가 자동적으로 해결</strong></li><li>보조기억장치 접근이 빈번하면 시스템 처리 효율이 저하</li><li>DASD에만 가능</li></ul><h2 id="주소"><a class="markdownIt-Anchor" href="#주소"></a> 주소</h2><ul><li>가상주소 : 논리주소로 보조기억장치 상의 주소</li><li>실기억주소 : 물리적주소로 주기억장치 상의 주소</li></ul><h2 id="관리"><a class="markdownIt-Anchor" href="#관리"></a> 관리</h2><ul><li>페이징 기법 : OS가 보조기억장치에 있는 프로그램을 동일한 크기의 블록으로 나눠서 관리</li><li>세그먼트 기법 : 사용자가 보조기억장치에 있는 프로그램을 가변적인 크기의 블록으로 나눠서 관리</li></ul><h2 id="관리전략"><a class="markdownIt-Anchor" href="#관리전략"></a> 관리전략</h2><h3 id="반입-전략"><a class="markdownIt-Anchor" href="#반입-전략"></a> 반입 전략</h3><ul><li>Fetch</li><li>보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인가?</li></ul><h3 id="배치-전략"><a class="markdownIt-Anchor" href="#배치-전략"></a> 배치 전략</h3><ul><li>Placement</li><li>새로 반입되는 포르개림이나 데이터를 주기억장치 어디에 위치시킬 것인가를 결정</li><li>최초, 최적, 최악접합이 있음</li></ul><h3 id="교체-전략"><a class="markdownIt-Anchor" href="#교체-전략"></a> 교체 전략</h3><ul><li>Replacement</li><li>주기억장치의 영역이 이미 사용중인 상태에서 새로운 프로그램을 주기억장치에 배치할 때 어떤 방식을 사용할지 결정하는 전략</li><li>FIFO, OPT, LRU, NUR, LFU, MFU 등</li><li>Page Fault 발생시 교체할 페이지를 결정해서 보조기억장치의 이전 위치에 기억시키고 새 페이지를 교체한 페이지의 위치에 놓는 것을 스테이징이라 한다</li><li>스테이징 : 느린 장치에서 바른 장치로 옮겨가는 것</li></ul><h2 id="주소-매핑"><a class="markdownIt-Anchor" href="#주소-매핑"></a> 주소 매핑</h2><ul><li>가상주소를 실 기억주소로 변환하는 작업</li><li>가상주소 형식 : 페이지 번호와 변위값</li><li>실기억주소 형식 : 페이지 프레임과 변위값</li><li>페이지 맵 테이블 : 디스크 페이지 번호와 페이지 프레임 번호, 상태 비트</li></ul><h3 id="변환-순서"><a class="markdownIt-Anchor" href="#변환-순서"></a> 변환 순서</h3><ul><li>페이지 번호에 해당하는 페이지 프레임 번호와 가상주소의 변위 주소값을 이용해 실 기억주소를 만듦</li><li>실기억주소를 이용하여 주기억장치를 액세스</li></ul><h1 id="병렬-컴퓨터"><a class="markdownIt-Anchor" href="#병렬-컴퓨터"></a> 병렬 컴퓨터</h1><ul><li>I/O 채널 또는 프로세서와 같은 다수의 프로세서에서 동시에 여러 프로세스를 처리하는 것</li><li>일부 하드웨어 오류가 발생해도 전체 시스템은 동작</li><li>처리 속도가 빠름</li><li>프로그램 작성이 어려움</li><li>기억장치 공유</li><li>특수한 업무에 적용 : 예보, 인공지능, 역학계산, 모의실험, 유도탄 등</li></ul><h2 id="flynn의-분류"><a class="markdownIt-Anchor" href="#flynn의-분류"></a> Flynn의 분류</h2><p>플린의 분류, 명령 흐름과 자료 흐름을 고려하여 분류</p><h3 id="sisd"><a class="markdownIt-Anchor" href="#sisd"></a> SISD</h3><ul><li>Single Instruction stream Single Data stream</li><li>현재 보통 컴퓨터 구조</li><li>명령 하나가 자료 하나를 처리</li><li>파이프라인에 의한 시간적 병렬 처리 가능</li></ul><h3 id="simd"><a class="markdownIt-Anchor" href="#simd"></a> SIMD</h3><ul><li>Single Instruction stream Multi Data Stream</li><li>한 개의 명령으로 여러 데이터를 동시에 처리하는 구조</li><li>배열 처리기에 의한 동기적 병렬처리가 가능</li><li>다수의 처리기가 한 개의 제어장치에 의해 제어</li></ul><h3 id="misd"><a class="markdownIt-Anchor" href="#misd"></a> MISD</h3><ul><li>Multi Instruction stream Single Data stream</li><li>다수의 처리기에 의해 각각의 명령들이 하나의 데이터를 처리하는 구조</li><li><strong>실제로 사용되지 않음</strong></li><li>파이프라인에 의한 비동기적 병렬처리 가능</li></ul><h3 id="mimd"><a class="markdownIt-Anchor" href="#mimd"></a> MIMD</h3><ul><li>Multi Instruction stream Multi Data stream</li><li>다수의 처리기가 각각 다른 명령 흐름과 자료 흐름을 가지고 여러 개의 자료를 처리하는 구조</li><li>각 처리기 사이에에서 상호작용(Interaction)이 일어남</li><li>멀티 프로세서에 의한 비동기적 병렬처리 가능</li><li>Tightly Coupled System = 다중 처리기</li><li>Loosely Coupled System = 분산 처리 시스템</li></ul><h2 id="feng의-분류"><a class="markdownIt-Anchor" href="#feng의-분류"></a> Feng의 분류</h2><p>팽은 병렬 수행 정도에 따라 분류</p><h3 id="wsbs"><a class="markdownIt-Anchor" href="#wsbs"></a> WSBS</h3><ul><li>Word-Serial, Bit-Serial</li><li>한 번에 한 비트씩 처리하는 방식 (초기 컴퓨터)</li></ul><h3 id="wpbs"><a class="markdownIt-Anchor" href="#wpbs"></a> WPBS</h3><ul><li>Word-Parallel, Bit-Serial</li><li>단어를 묶어서 그 중 한 개의 비트 슬라이스 단위를 순차적으로 처리</li></ul><h3 id="wsbp"><a class="markdownIt-Anchor" href="#wsbp"></a> WSBP</h3><ul><li>Word-Sreial, Bit-Parallel</li><li>한 번에 한 단어씩 병렬로 처리</li><li>현재의 컴퓨터</li></ul><h3 id="wpbp"><a class="markdownIt-Anchor" href="#wpbp"></a> WPBP</h3><ul><li>Word-Parallel, Bit-Parellel</li><li>단어별 병렬, 비트별 병렬 처리</li></ul><h1 id="병렬-처리-기법"><a class="markdownIt-Anchor" href="#병렬-처리-기법"></a> 병렬 처리 기법</h1><h2 id="파이프라인-프로세서"><a class="markdownIt-Anchor" href="#파이프라인-프로세서"></a> 파이프라인 프로세서</h2><ul><li>CPU 처리속도를 높이기 위해 여러개의 인스트럭션을 동시에 병렬처리하는 장치</li><li>시간적 병렬처리</li><li>명령인출 =&gt; 명령 해독 =&gt; 오퍼랜드 인출 =&gt; 명령 실행</li><li>스칼라 프로세서를 이용하는 기법</li><li>파이프라인이 차고 나면 연산속도가 빠르다.</li><li>같은 연산이 반복되면 효율적이지만 아니면 구조가 복잡하고 시간이 오래 걸린다.</li></ul><h2 id="벡터-프로세서"><a class="markdownIt-Anchor" href="#벡터-프로세서"></a> 벡터 프로세서</h2><p>산술 및 논리연산, 비교, 내적연산, 최대, 최소값 구하기 등 벡터 연산 명령을 효율적으로 수행하도록 구성된 처리기</p><h3 id="시스톨릭-프로세서"><a class="markdownIt-Anchor" href="#시스톨릭-프로세서"></a> 시스톨릭 프로세서</h3><ul><li>데이터 흐름과 제어 흐름이 규칙적인 특징을 갖는 시스톨릭 알고리즘을 이용하여 수행하는 처리기</li><li>파이프라인화 된 벡터 프로세서와 배열 프로세서의 특징을 결합한 것</li><li>초고밀도 직접회로(VLSI) 기법을 이용하여 구현</li><li>응용의 한계성과 프로그래밍의 어려움이 있음</li></ul><h2 id="배열-프로세서"><a class="markdownIt-Anchor" href="#배열-프로세서"></a> 배열 프로세서</h2><ul><li>배열처리기는 PE(Processing Element)라 불리는 다수의 연산기를 갖는 <strong>동기적 병렬 처리기</strong></li><li>명령 해독 및 제어는 제어장치가 하고, PE들는 명령 해독 능력이 결여된 수동적 장치로 명령처리만 한다.</li><li>PE를 중복 이용해서 공간적 병렬성을 얻는다.</li><li>벡터 계산이나 행렬 계산에 적합</li></ul><h2 id="데이터-플로우-컴퓨터"><a class="markdownIt-Anchor" href="#데이터-플로우-컴퓨터"></a> 데이터 플로우 컴퓨터</h2><ul><li>데이터 흐름 컴퓨터는 PC(Program Counter)가 필요 없다.</li><li>제어 흐름 컴퓨터와는 반대되는 개념</li><li>인스트럭션의 필요한 피연산자가 모두 준비되었을 때 인스트럭션을 수행하고 결과를 필요로하는 인스트럭션에 보내주는 방식</li></ul></div><script src="https://ads-partners.coupang.com/g.js"></script><script>new PartnersCoupang.G({id:115781})</script><br><div id="reward-container"><a href="https://www.buymeacoffee.com/LOUB2kN" target="_blank" rel="external nofollow noopener noreferrer"><img src="https://www.buymeacoffee.com/assets/img/custom_images/purple_img.png" style="height:auto!important;width:auto!important"></a></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Gracefullight</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://gracefullight.dev/2017/01/29/%EC%A0%84%EC%9E%90%EA%B3%84%EC%82%B0%EA%B8%B0-%EA%B5%AC%EC%A1%B0-%EC%A0%95%EB%A6%AC/" title="전자계산기 구조 정리">https://gracefullight.dev/2017/01/29/전자계산기-구조-정리/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.ko" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-SA</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC/" rel="tag"><i class="fa fa-tag"></i> 정보처리</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2017/01/23/database-%EC%A0%95%EB%A6%AC/" rel="prev" title="Database 정리"><i class="fa fa-chevron-left"></i> Database 정리</a></div><div class="post-nav-item"><a href="/2017/02/01/Nginx-for-Windows/" rel="next" title="Nginx for Windows - 1. Setup">Nginx for Windows - 1. Setup <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments"><div id="disqus_thread"><noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">목차</li><li class="sidebar-nav-overview">흝어보기</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#불-대수"><span class="nav-number">1.</span> <span class="nav-text">불 대수</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#기본-공식"><span class="nav-number">1.1.</span> <span class="nav-text">기본 공식</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#카르노-맵"><span class="nav-number">1.2.</span> <span class="nav-text">카르노 맵</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#논리-게이트"><span class="nav-number">2.</span> <span class="nav-text">논리 게이트</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#조합논리회로"><span class="nav-number">3.</span> <span class="nav-text">조합논리회로</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#반가산기"><span class="nav-number">3.1.</span> <span class="nav-text">반가산기</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#전가산기"><span class="nav-number">3.2.</span> <span class="nav-text">전가산기</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#병렬가산기"><span class="nav-number">3.3.</span> <span class="nav-text">병렬가산기</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#반감산기"><span class="nav-number">3.4.</span> <span class="nav-text">반감산기</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#디코더"><span class="nav-number">3.5.</span> <span class="nav-text">디코더</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#인코더"><span class="nav-number">3.6.</span> <span class="nav-text">인코더</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#멀티플렉서"><span class="nav-number">3.7.</span> <span class="nav-text">멀티플렉서</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#디멀티플렉서"><span class="nav-number">3.8.</span> <span class="nav-text">디멀티플렉서</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#순서논리회로"><span class="nav-number">4.</span> <span class="nav-text">순서논리회로</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#플리플롭"><span class="nav-number">4.1.</span> <span class="nav-text">플리플롭</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#특성표"><span class="nav-number">4.1.1.</span> <span class="nav-text">특성표</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#여기표"><span class="nav-number">4.1.2.</span> <span class="nav-text">여기표</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rs-플립플롭"><span class="nav-number">4.1.3.</span> <span class="nav-text">RS 플립플롭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-플립플롭"><span class="nav-number">4.1.4.</span> <span class="nav-text">D 플립플롭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jk-플립플롭"><span class="nav-number">4.1.5.</span> <span class="nav-text">JK 플립플롭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#t-플립플롭"><span class="nav-number">4.1.6.</span> <span class="nav-text">T 플립플롭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ms-플립플롭"><span class="nav-number">4.1.7.</span> <span class="nav-text">M&#x2F;S 플립플롭</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#자료-구성-단위"><span class="nav-number">5.</span> <span class="nav-text">자료 구성 단위</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#비트"><span class="nav-number">5.1.</span> <span class="nav-text">비트</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#니블"><span class="nav-number">5.2.</span> <span class="nav-text">니블</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#바이트"><span class="nav-number">5.3.</span> <span class="nav-text">바이트</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#워드"><span class="nav-number">5.4.</span> <span class="nav-text">워드</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#필드"><span class="nav-number">5.5.</span> <span class="nav-text">필드</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#레코드"><span class="nav-number">5.6.</span> <span class="nav-text">레코드</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#블록"><span class="nav-number">5.7.</span> <span class="nav-text">블록</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#파일"><span class="nav-number">5.8.</span> <span class="nav-text">파일</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#데이터베이스"><span class="nav-number">5.9.</span> <span class="nav-text">데이터베이스</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#진법"><span class="nav-number">6.</span> <span class="nav-text">진법</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2진수"><span class="nav-number">6.1.</span> <span class="nav-text">2진수</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8진수"><span class="nav-number">6.2.</span> <span class="nav-text">8진수</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16진수"><span class="nav-number">6.3.</span> <span class="nav-text">16진수</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#보수"><span class="nav-number">7.</span> <span class="nav-text">보수</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#뺄셈"><span class="nav-number">7.1.</span> <span class="nav-text">뺄셈</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#고정-소수점"><span class="nav-number">8.</span> <span class="nav-text">고정 소수점</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2진연산"><span class="nav-number">8.1.</span> <span class="nav-text">2진연산</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#음수연산"><span class="nav-number">8.1.1.</span> <span class="nav-text">음수연산</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10진연산"><span class="nav-number">8.2.</span> <span class="nav-text">10진연산</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#언팩연산"><span class="nav-number">8.2.1.</span> <span class="nav-text">언팩연산</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#팩연산"><span class="nav-number">8.2.2.</span> <span class="nav-text">팩연산</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#부동소수점"><span class="nav-number">9.</span> <span class="nav-text">부동소수점</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ieee-표준"><span class="nav-number">9.1.</span> <span class="nav-text">IEEE 표준</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#연산"><span class="nav-number">9.2.</span> <span class="nav-text">연산</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#덧셈-및-뺄셈"><span class="nav-number">9.2.1.</span> <span class="nav-text">덧셈 및 뺄셈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#곱셈"><span class="nav-number">9.2.2.</span> <span class="nav-text">곱셈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#나눗셈"><span class="nav-number">9.2.3.</span> <span class="nav-text">나눗셈</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#자료-표현"><span class="nav-number">10.</span> <span class="nav-text">자료 표현</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#bcd"><span class="nav-number">10.1.</span> <span class="nav-text">BCD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ascii"><span class="nav-number">10.2.</span> <span class="nav-text">ASCII</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ebcdic"><span class="nav-number">10.3.</span> <span class="nav-text">EBCDIC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bcd-코드"><span class="nav-number">10.4.</span> <span class="nav-text">BCD 코드</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#excess3-코드"><span class="nav-number">10.5.</span> <span class="nav-text">Excess3 코드</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gray-코드"><span class="nav-number">10.6.</span> <span class="nav-text">Gray 코드</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#패리티-코드"><span class="nav-number">10.7.</span> <span class="nav-text">패리티 코드</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#홀수-패리티"><span class="nav-number">10.7.1.</span> <span class="nav-text">홀수 패리티</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#짝수-패리티"><span class="nav-number">10.7.2.</span> <span class="nav-text">짝수 패리티</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#해밍-코드"><span class="nav-number">10.8.</span> <span class="nav-text">해밍 코드</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#코드-분류"><span class="nav-number">10.9.</span> <span class="nav-text">코드 분류</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#중앙처리장치"><span class="nav-number">11.</span> <span class="nav-text">중앙처리장치</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#제어장치"><span class="nav-number">11.1.</span> <span class="nav-text">제어장치</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#구성요소"><span class="nav-number">11.1.1.</span> <span class="nav-text">구성요소</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#연산장치"><span class="nav-number">11.2.</span> <span class="nav-text">연산장치</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#레지스터"><span class="nav-number">11.3.</span> <span class="nav-text">레지스터</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#자료전송"><span class="nav-number">11.3.1.</span> <span class="nav-text">자료전송</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#주요-레지스터"><span class="nav-number">11.3.2.</span> <span class="nav-text">주요 레지스터</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#버스"><span class="nav-number">11.4.</span> <span class="nav-text">버스</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#종류"><span class="nav-number">11.4.1.</span> <span class="nav-text">종류</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#명령어"><span class="nav-number">12.</span> <span class="nav-text">명령어</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#연산자부"><span class="nav-number">12.1.</span> <span class="nav-text">연산자부</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#모드부"><span class="nav-number">12.2.</span> <span class="nav-text">모드부</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#자료부"><span class="nav-number">12.3.</span> <span class="nav-text">자료부</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#설계시-고려사항"><span class="nav-number">12.4.</span> <span class="nav-text">설계시 고려사항</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#기능"><span class="nav-number">12.5.</span> <span class="nav-text">기능</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#함수-연산-기능"><span class="nav-number">12.5.1.</span> <span class="nav-text">함수 연산 기능</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#자료-전달-기능"><span class="nav-number">12.5.2.</span> <span class="nav-text">자료 전달 기능</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#제어-기능"><span class="nav-number">12.5.3.</span> <span class="nav-text">제어 기능</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#입출력-기능"><span class="nav-number">12.5.4.</span> <span class="nav-text">입출력 기능</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#연산-2"><span class="nav-number">13.</span> <span class="nav-text">연산</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#and"><span class="nav-number">13.1.</span> <span class="nav-text">AND</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#or"><span class="nav-number">13.2.</span> <span class="nav-text">OR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#xor"><span class="nav-number">13.3.</span> <span class="nav-text">XOR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#not"><span class="nav-number">13.4.</span> <span class="nav-text">NOT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#논리-shift"><span class="nav-number">13.5.</span> <span class="nav-text">논리 Shift</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rotate"><span class="nav-number">13.6.</span> <span class="nav-text">Rotate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#산술-shift"><span class="nav-number">13.7.</span> <span class="nav-text">산술 Shift</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shift-left"><span class="nav-number">13.7.1.</span> <span class="nav-text">Shift Left</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shift-right"><span class="nav-number">13.7.2.</span> <span class="nav-text">Shift Right</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#명령어-형식"><span class="nav-number">14.</span> <span class="nav-text">명령어 형식</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3주소-명령어"><span class="nav-number">14.1.</span> <span class="nav-text">3주소 명령어</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#장점"><span class="nav-number">14.1.1.</span> <span class="nav-text">장점</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#단점"><span class="nav-number">14.1.2.</span> <span class="nav-text">단점</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2주소-명령어"><span class="nav-number">14.2.</span> <span class="nav-text">2주소 명령어</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#장점-2"><span class="nav-number">14.2.1.</span> <span class="nav-text">장점</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#단점-2"><span class="nav-number">14.2.2.</span> <span class="nav-text">단점</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1주소-명령어"><span class="nav-number">14.3.</span> <span class="nav-text">1주소 명령어</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0주소-명령어"><span class="nav-number">14.4.</span> <span class="nav-text">0주소 명령어</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#주소지정방식"><span class="nav-number">15.</span> <span class="nav-text">주소지정방식</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#고려사항"><span class="nav-number">15.1.</span> <span class="nav-text">고려사항</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#암시적-주소지정방식"><span class="nav-number">15.2.</span> <span class="nav-text">암시적 주소지정방식</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#즉시적-주소지정방식"><span class="nav-number">15.3.</span> <span class="nav-text">즉시적 주소지정방식</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#직접-주소지정방식"><span class="nav-number">15.4.</span> <span class="nav-text">직접 주소지정방식</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#간접-주소지정방식"><span class="nav-number">15.5.</span> <span class="nav-text">간접 주소지정방식</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#계산에-의한-주소지정방식"><span class="nav-number">15.6.</span> <span class="nav-text">계산에 의한 주소지정방식</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#마이크로-오퍼레이션"><span class="nav-number">16.</span> <span class="nav-text">마이크로 오퍼레이션</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#마이크로-사이클-타임"><span class="nav-number">16.1.</span> <span class="nav-text">마이크로 사이클 타임</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#동기-고정식"><span class="nav-number">16.1.1.</span> <span class="nav-text">동기 고정식</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#동기-가변식"><span class="nav-number">16.1.2.</span> <span class="nav-text">동기 가변식</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#비동기식"><span class="nav-number">16.1.3.</span> <span class="nav-text">비동기식</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#메이저-스테이트"><span class="nav-number">17.</span> <span class="nav-text">메이저 스테이트</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#fetch-cycle"><span class="nav-number">17.1.</span> <span class="nav-text">Fetch Cycle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#indirect-cycle"><span class="nav-number">17.2.</span> <span class="nav-text">Indirect Cycle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#execute-cycle"><span class="nav-number">17.3.</span> <span class="nav-text">Execute Cycle</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#interrupt-cycle"><span class="nav-number">17.4.</span> <span class="nav-text">Interrupt Cycle</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#주요-마이크로-오퍼레이션"><span class="nav-number">18.</span> <span class="nav-text">주요 마이크로 오퍼레이션</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#and-2"><span class="nav-number">18.1.</span> <span class="nav-text">AND</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#add"><span class="nav-number">18.2.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lda"><span class="nav-number">18.3.</span> <span class="nav-text">LDA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sta"><span class="nav-number">18.4.</span> <span class="nav-text">STA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bun"><span class="nav-number">18.5.</span> <span class="nav-text">BUN</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bsa"><span class="nav-number">18.6.</span> <span class="nav-text">BSA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#isz"><span class="nav-number">18.7.</span> <span class="nav-text">ISZ</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#제어기"><span class="nav-number">19.</span> <span class="nav-text">제어기</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#제어데이터"><span class="nav-number">19.1.</span> <span class="nav-text">제어데이터</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#종류-2"><span class="nav-number">19.1.1.</span> <span class="nav-text">종류</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#단계"><span class="nav-number">19.1.2.</span> <span class="nav-text">단계</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#구현"><span class="nav-number">19.2.</span> <span class="nav-text">구현</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#고정배선-제어장치"><span class="nav-number">19.2.1.</span> <span class="nav-text">고정배선 제어장치</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#마이크로-프로그래밍"><span class="nav-number">19.2.2.</span> <span class="nav-text">마이크로 프로그래밍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#제어-메모리-번지-결정"><span class="nav-number">19.3.</span> <span class="nav-text">제어 메모리 번지 결정</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#형식"><span class="nav-number">19.4.</span> <span class="nav-text">형식</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#수평-마이크로-명령"><span class="nav-number">19.4.1.</span> <span class="nav-text">수평 마이크로 명령</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#수직-마이크로-명령"><span class="nav-number">19.4.2.</span> <span class="nav-text">수직 마이크로 명령</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#나노-명령"><span class="nav-number">19.4.3.</span> <span class="nav-text">나노 명령</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#제어장치-구현방식"><span class="nav-number">19.5.</span> <span class="nav-text">제어장치 구현방식</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#입출력장치"><span class="nav-number">20.</span> <span class="nav-text">입출력장치</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#입출력-제어장치"><span class="nav-number">20.1.</span> <span class="nav-text">입출력 제어장치</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#입출력-인터페이스"><span class="nav-number">20.2.</span> <span class="nav-text">입출력 인터페이스</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#입출력-버스"><span class="nav-number">20.3.</span> <span class="nav-text">입출력 버스</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#기억장치와-입출력장치의-차이"><span class="nav-number">20.4.</span> <span class="nav-text">기억장치와 입출력장치의 차이</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#비동기-데이터-전송"><span class="nav-number">20.5.</span> <span class="nav-text">비동기 데이터 전송</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#스트로브-펄스"><span class="nav-number">20.5.1.</span> <span class="nav-text">스트로브 펄스</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#핸드쉐이킹"><span class="nav-number">20.5.2.</span> <span class="nav-text">핸드쉐이킹</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#스풀링"><span class="nav-number">20.6.</span> <span class="nav-text">스풀링</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#버퍼링"><span class="nav-number">20.7.</span> <span class="nav-text">버퍼링</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#입출력-제어방식"><span class="nav-number">21.</span> <span class="nav-text">입출력 제어방식</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#programmed-io"><span class="nav-number">21.1.</span> <span class="nav-text">Programmed I&#x2F;O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#interrupt-io"><span class="nav-number">21.2.</span> <span class="nav-text">Interrupt I&#x2F;O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dma-io"><span class="nav-number">21.3.</span> <span class="nav-text">DMA I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#구성"><span class="nav-number">21.3.1.</span> <span class="nav-text">구성</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#channel-io"><span class="nav-number">21.4.</span> <span class="nav-text">Channel I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#채널-명령어"><span class="nav-number">21.4.1.</span> <span class="nav-text">채널 명령어</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#종류-3"><span class="nav-number">21.4.2.</span> <span class="nav-text">종류</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#인터럽트"><span class="nav-number">22.</span> <span class="nav-text">인터럽트</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#외부-인터럽트"><span class="nav-number">22.1.</span> <span class="nav-text">외부 인터럽트</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#내부-인터럽트"><span class="nav-number">22.2.</span> <span class="nav-text">내부 인터럽트</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#소프트웨어-인터럽트"><span class="nav-number">22.3.</span> <span class="nav-text">소프트웨어 인터럽트</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#인터럽트시-cpu확인-요소"><span class="nav-number">22.4.</span> <span class="nav-text">인터럽트시 CPU확인 요소</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#동작-원리"><span class="nav-number">22.5.</span> <span class="nav-text">동작 원리</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#인터럽트-우선순위"><span class="nav-number">23.</span> <span class="nav-text">인터럽트 우선순위</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#폴링"><span class="nav-number">23.1.</span> <span class="nav-text">폴링</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#벡터-인터럽트"><span class="nav-number">23.2.</span> <span class="nav-text">벡터 인터럽트</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#직렬-우선순위"><span class="nav-number">23.2.1.</span> <span class="nav-text">직렬 우선순위</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#병렬-우선순위"><span class="nav-number">23.2.2.</span> <span class="nav-text">병렬 우선순위</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#기억장치"><span class="nav-number">24.</span> <span class="nav-text">기억장치</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#계층구조"><span class="nav-number">24.1.</span> <span class="nav-text">계층구조</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#특성-결정-요소"><span class="nav-number">24.2.</span> <span class="nav-text">특성 결정 요소</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#기억-용량"><span class="nav-number">24.2.1.</span> <span class="nav-text">기억 용량</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#access-time"><span class="nav-number">24.2.2.</span> <span class="nav-text">Access Time</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cycle-time"><span class="nav-number">24.2.3.</span> <span class="nav-text">Cycle Time</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bandwitdh"><span class="nav-number">24.2.4.</span> <span class="nav-text">Bandwitdh</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#구분"><span class="nav-number">24.3.</span> <span class="nav-text">구분</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#주기억장치"><span class="nav-number">25.</span> <span class="nav-text">주기억장치</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#rom"><span class="nav-number">25.1.</span> <span class="nav-text">ROM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#종류-4"><span class="nav-number">25.1.1.</span> <span class="nav-text">종류</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ram"><span class="nav-number">25.2.</span> <span class="nav-text">RAM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#자기-코어"><span class="nav-number">25.3.</span> <span class="nav-text">자기 코어</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#구성-2"><span class="nav-number">25.3.1.</span> <span class="nav-text">구성</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#반도체-기억소자-구성"><span class="nav-number">25.4.</span> <span class="nav-text">반도체 기억소자 구성</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ram-2"><span class="nav-number">25.4.1.</span> <span class="nav-text">RAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rom-2"><span class="nav-number">25.4.2.</span> <span class="nav-text">ROM</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#보조기억장치"><span class="nav-number">26.</span> <span class="nav-text">보조기억장치</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#자기-테이프"><span class="nav-number">26.1.</span> <span class="nav-text">자기 테이프</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#자기-디스크"><span class="nav-number">26.2.</span> <span class="nav-text">자기 디스크</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#디스크의-3요소"><span class="nav-number">26.2.1.</span> <span class="nav-text">디스크의 3요소</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#access-time-2"><span class="nav-number">26.2.2.</span> <span class="nav-text">Access Time</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#자기-드럼"><span class="nav-number">26.3.</span> <span class="nav-text">자기 드럼</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#연관기억장치"><span class="nav-number">27.</span> <span class="nav-text">연관기억장치</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#구조"><span class="nav-number">27.1.</span> <span class="nav-text">구조</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#복수모듈기억장치"><span class="nav-number">28.</span> <span class="nav-text">복수모듈기억장치</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#메모리-인터리빙"><span class="nav-number">28.1.</span> <span class="nav-text">메모리 인터리빙</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#캐시-메모리"><span class="nav-number">29.</span> <span class="nav-text">캐시 메모리</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#설계-고려사항"><span class="nav-number">29.1.</span> <span class="nav-text">설계 고려사항</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#매핑-프로세스"><span class="nav-number">29.2.</span> <span class="nav-text">매핑 프로세스</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#직접-매핑"><span class="nav-number">29.2.1.</span> <span class="nav-text">직접 매핑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#어소시에이티브-매핑"><span class="nav-number">29.2.2.</span> <span class="nav-text">어소시에이티브 매핑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#세트-어소시에이티브-매핑"><span class="nav-number">29.2.3.</span> <span class="nav-text">세트-어소시에이티브 매핑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#쓰기-정책"><span class="nav-number">29.3.</span> <span class="nav-text">쓰기 정책</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#적중률"><span class="nav-number">29.4.</span> <span class="nav-text">적중률</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#가상기억장치"><span class="nav-number">30.</span> <span class="nav-text">가상기억장치</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#주소"><span class="nav-number">30.1.</span> <span class="nav-text">주소</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#관리"><span class="nav-number">30.2.</span> <span class="nav-text">관리</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#관리전략"><span class="nav-number">30.3.</span> <span class="nav-text">관리전략</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#반입-전략"><span class="nav-number">30.3.1.</span> <span class="nav-text">반입 전략</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#배치-전략"><span class="nav-number">30.3.2.</span> <span class="nav-text">배치 전략</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#교체-전략"><span class="nav-number">30.3.3.</span> <span class="nav-text">교체 전략</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#주소-매핑"><span class="nav-number">30.4.</span> <span class="nav-text">주소 매핑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#변환-순서"><span class="nav-number">30.4.1.</span> <span class="nav-text">변환 순서</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#병렬-컴퓨터"><span class="nav-number">31.</span> <span class="nav-text">병렬 컴퓨터</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#flynn의-분류"><span class="nav-number">31.1.</span> <span class="nav-text">Flynn의 분류</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#sisd"><span class="nav-number">31.1.1.</span> <span class="nav-text">SISD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#simd"><span class="nav-number">31.1.2.</span> <span class="nav-text">SIMD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#misd"><span class="nav-number">31.1.3.</span> <span class="nav-text">MISD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mimd"><span class="nav-number">31.1.4.</span> <span class="nav-text">MIMD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#feng의-분류"><span class="nav-number">31.2.</span> <span class="nav-text">Feng의 분류</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#wsbs"><span class="nav-number">31.2.1.</span> <span class="nav-text">WSBS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wpbs"><span class="nav-number">31.2.2.</span> <span class="nav-text">WPBS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wsbp"><span class="nav-number">31.2.3.</span> <span class="nav-text">WSBP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wpbp"><span class="nav-number">31.2.4.</span> <span class="nav-text">WPBP</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#병렬-처리-기법"><span class="nav-number">32.</span> <span class="nav-text">병렬 처리 기법</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#파이프라인-프로세서"><span class="nav-number">32.1.</span> <span class="nav-text">파이프라인 프로세서</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#벡터-프로세서"><span class="nav-number">32.2.</span> <span class="nav-text">벡터 프로세서</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#시스톨릭-프로세서"><span class="nav-number">32.2.1.</span> <span class="nav-text">시스톨릭 프로세서</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#배열-프로세서"><span class="nav-number">32.3.</span> <span class="nav-text">배열 프로세서</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#데이터-플로우-컴퓨터"><span class="nav-number">32.4.</span> <span class="nav-text">데이터 플로우 컴퓨터</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Gracefullight" src="/images/profile_dog.png"><p class="site-author-name" itemprop="name">Gracefullight</p><div class="site-description" itemprop="description">풀스택 개발자를 꿈꾸며</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">288</span> <span class="site-state-item-name">포스트</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">71</span> <span class="site-state-item-name">카테고리</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">148</span> <span class="site-state-item-name">태그</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/gracefullight" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;gracefullight" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i></a> </span><span class="links-of-author-item"><a href="mailto:eks012@gmail.com" title="E-Mail → mailto:eks012@gmail.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i></a> </span><span class="links-of-author-item"><a href="https://www.facebook.com/eunkwang.daniel.shin" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;eunkwang.daniel.shin" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-facebook"></i></a></span></div><script src="https://ads-partners.coupang.com/g.js"></script><script>new PartnersCoupang.G({id:115781})</script></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2016 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Gracefullight</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="Symbols count total">568k</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="Total Visitors"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="Total Views"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script>window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://gracefullight.dev/2017/01/29/%EC%A0%84%EC%9E%90%EA%B3%84%EC%82%B0%EA%B8%B0-%EA%B5%AC%EC%A1%B0-%EC%A0%95%EB%A6%AC/',(uri, el) => el.hasAttribute('noopener')]
      });
      });</script><script>function loadCount(){var d=document,t=d.createElement("script");t.src="https://gracefullight.disqus.com/count.js",t.id="dsq-count-scr",(d.head||d.body).appendChild(t)}window.addEventListener("load",loadCount,!1)</script><script>var disqus_config = function() {
    this.page.url = "https://gracefullight.dev/2017/01/29/%EC%A0%84%EC%9E%90%EA%B3%84%EC%82%B0%EA%B8%B0-%EA%B5%AC%EC%A1%B0-%EC%A0%95%EB%A6%AC/";
    this.page.identifier = "2017/01/29/전자계산기-구조-정리/";
    this.page.title = "전자계산기 구조 정리";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://gracefullight.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });</script><script src="/a2hs.js"></script><script>AddToHomeScreen({
  color: "#682984",
  htmlContent: `Install <strong>Blog</strong> on your iOS device: tap share and <strong>Add to Home Screen <i class="fa fa-plus-square-o" aria-hidden="true"></i>`,
  logoImage: `<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="32px" height="32px" viewBox="0 0 32 32" enable-background="new 0 0 32 32" xml:space="preserve">
    <image id="image0" width="32" height="32" x="0" y="0"
      xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABwlBMVEUAAABoKYRoKYRoKYRo
KYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRo
KYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRoKYRmJ4NlJYJmJoNnKINmJoJnJ4NrLYaCTpmh
erK3mcTApsy/pMuzk8Gdc69/SpdqLIaHVp7IstPy7PT+/v7////9/f7w6fLFrdB4QJFpKoSgeLHv
6PLw6vOAS5eacK318Pf9/P7l2+rDqs6yksC0lcLGrtHj1+j8+/3Uw9xtMIh7RJTl2ur39Pm0lMJ3
PpB0Oo6YbKuvjr79/P2wkL9nKIRoKIRwNIrbzOLf0uVzOY3x6vNsL4d5QZKMW6H59vqherOGVJ3m
2+rs5O/r4+/p3+2OXqOPYaT6+Pv//v+edrCLWqD49fr8+vyTZqeKWZ+ujL2FU5zh1ed7RZTt5fDU
wdxrLYeMXKHz7/bRvdn59/qhebKAS5jy7fWccq76+fvx7PSog7hkJIFuMYnHr9Hh1ObBp8yxkL+w
j77ErM/LtdVwNIvi1ud0O46SZKa5nMangrd1PI9pKoVmJYIBdN/qXMTWAAAAIXRSTlMAAAQoa6zZ
8v0DNpbf+xqJ6YgZNcL+QdjBAineq/w36OoVlKlsAAAAAWJLR0SVCGB6gwAAAAd0SU1FB+QBDAkd
FjLeh/4AAAH+SURBVDjLhZPpW1JBFMZnFLkIygU3vALqADO3MosWT6ktltrilhVFRZYaZZRr+25p
m5Va1h/cwJ0FeHwe3k9zz/ndmTPvnIOQEK6qdtW4DY/HcNe4qqswKhWu9frq6olQfZ3PW1uMYOw3
A6REgWADxjrf2NRMytTc1CgJjFvcZBe5WxyC/x8iuyrk7IH9rToWiycoZXHb+Wr1cwBbpk7v2buv
a3/3gYPJQ7QQMC2MsFfVTw8fOdoDXMeO9/YViIAXI8sn8/0nToLUqdPOKT4LtYVF3h44A3B2cGj4
3PkLF0dGnWC4DbmEf/bYOMDEpUnCGLk8cIUKT10oIje4CpC61l/YmbLr8twIEh6kb9wEuJXJ/0ht
LuUFMsQGydsAXTG+muq7wyVqIAbyOAt2dxpgJk5IYvZe9n72wRxz4h4FPMzBo8ccYPML/JqLSwKI
yiPY8gTACo8mnjzNpjRgyCLtZ88BXozy6l9mXr3WQEhdc+oNwNt3MX4N9v6DBiLKKLb6EeDTWoay
9aQGuFHS6vTnL/nivn77vvEjpwButXose/JnSj2WBPhj4fYOSfxa28w5+enN2bxnpKOd94MVVP1g
b22vdPcO/f4zt/O3EAlauLTlKGOUpGP/GNUtV7lpK7Z95cHJEw1mZ2m+0ywaPTG8YT284bLhLRr/
aLRs/P8DbZGRYkxcNtEAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDEtMTJUMDk6Mjk6MjIrMDM6
MDA/mynTAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTAxLTEyVDA5OjI5OjIyKzAzOjAwTsaRbwAA
AABJRU5ErkJggg=="/>
</svg>
`
});</script></body></html>